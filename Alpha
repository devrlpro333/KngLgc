--[[
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   âš¡ FLASH TP ALPHA V4.0 - VIP PREMIUM EDITION âš¡          â•‘
â•‘   ğŸ”¥ ASTRAL PROJECTION - SOUL SEPARATION SYSTEM            â•‘
â•‘   ğŸ‘» GHOST MODE - 3 MODES: SOUL, PHANTOM, WRAITH           â•‘
â•‘   âœ¨ ADVANCED FLY - 4 MODES: NORMAL, SONIC, TELEPORT, GOD  â•‘
â•‘   ğŸ˜ˆ DEMON V4 - MYTHICAL AWAKENING WITH TRANSFORMATIONS    â•‘
â•‘   ğŸ¯ SMART TELEPORT - AI-POWERED LOCATION FINDER           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--]]

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")

local LP = Players.LocalPlayer

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“ ISLANDS DATABASE (King Legacy optimized)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Islands = {
	{N = "Dungeon", P = Vector3.new(10959.99, 134.04, 1250.57), I = "ğŸ°", T = "Boss"},
	{N = "Alien Island", P = Vector3.new(2186.42, 35.82, 1302.21), I = "ğŸ‘½", T = "Special"},
	{N = "Random Fruit", P = Vector3.new(2064.01, 36.25, 1093.72), I = "ğŸ", T = "Shop"},
	{N = "Reset Race Stats", P = Vector3.new(2052.92, 71.81, 1071.29), I = "ğŸ”„", T = "NPC"},
	{N = "Fruit Shop", P = Vector3.new(2154.84, 79.04, 824.23), I = "ğŸ›’", T = "Shop"},
	{N = "Sea Event", P = Vector3.new(2227.14, 362.20, -1205.43), I = "ğŸŒŠ", T = "Event"},
	{N = "Saber Lord", P = Vector3.new(1687.59, 289.10, -1166.54), I = "âš”ï¸", T = "Boss"},
	{N = "Awaken Fruit", P = Vector3.new(2066.98, 54.82, 551.41), I = "âœ¨", T = "Special"},
	{N = "Monkey Island", P = Vector3.new(3725.56, 45.42, 8813.90), I = "ğŸ’", T = "Island"},
	{N = "Sea Beasts", P = Vector3.new(4543.48, 47.37, 11622.30), I = "ğŸ‰", T = "Boss"},
	{N = "Luma Forest", P = Vector3.new(-3935.36, 77.38, 6265.37), I = "ğŸŒ²", T = "Island"},
	{N = "Forgotten Arena", P = Vector3.new(-6105.61, 33.69, 1014.73), I = "ğŸŸï¸", T = "PVP"},
	{N = "Drakenhole Fort", P = Vector3.new(6948.99, 49.78, -5753.79), I = "ğŸ²", T = "Boss"},
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸŒ VIETNAMESE TO ENGLISH TRANSLATION MAP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ViToEn = {
	["nguc toi"] = "dungeon", ["hang nguc"] = "dungeon",
	["dao nguoi ngoai hanh tinh"] = "alien island", ["nguoi ngoai hanh tinh"] = "alien",
	["trai cay ngau nhien"] = "random fruit", ["ngau nhien"] = "random",
	["dat lai"] = "reset", ["dat lai chung toc"] = "reset race",
	["cua hang trai cay"] = "fruit shop", ["cua hang"] = "shop",
	["su kien bien"] = "sea event", ["bien"] = "sea",
	["chua te kiem"] = "saber lord", ["kiem"] = "saber",
	["thuc tinh trai cay"] = "awaken fruit", ["thuc tinh"] = "awaken",
	["dao khi"] = "monkey island", ["khi"] = "monkey",
	["quai vat bien"] = "sea beasts", ["quai vat"] = "beasts",
	["rung luma"] = "luma forest", ["rung"] = "forest",
	["dau truong bi lang quen"] = "forgotten arena", ["dau truong"] = "arena",
	["phao dai"] = "drakenhole fort", ["rong"] = "drakenhole",
	["boss"] = "boss", ["trum"] = "boss",
	["nha buon"] = "dealer", ["thuong nhan"] = "merchant",
	["dao"] = "island", ["npc"] = "npc",
	["quan"] = "shop", ["mua"] = "buy",
	["ban"] = "sell", ["nhiem vu"] = "quest",
	["vua"] = "king", ["hai tac"] = "pirate",
	["thuy thu"] = "marine", ["linh"] = "marine",
	["tho reo"] = "blacksmith", ["tho"] = "smith",
	["bac si"] = "doctor", ["y ta"] = "nurse",
	["tien thuong"] = "bounty", ["san tien"] = "bounty",
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¨ PREMIUM COLOR SCHEME
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local C = {
	bg = Color3.fromRGB(8, 8, 12),
	panel = Color3.fromRGB(15, 15, 20),
	card = Color3.fromRGB(22, 22, 30),
	cardH = Color3.fromRGB(32, 32, 42),
	accent = Color3.fromRGB(88, 166, 255),
	accentH = Color3.fromRGB(108, 186, 255),
	green = Color3.fromRGB(52, 211, 153),
	red = Color3.fromRGB(248, 113, 113),
	orange = Color3.fromRGB(251, 191, 36),
	purple = Color3.fromRGB(168, 85, 247),
	pink = Color3.fromRGB(236, 72, 153),
	cyan = Color3.fromRGB(34, 211, 238),
	text = Color3.fromRGB(248, 250, 252),
	dim = Color3.fromRGB(148, 163, 184),
	stroke = Color3.fromRGB(30, 41, 59),
	tab = Color3.fromRGB(15, 23, 42),
	tabA = Color3.fromRGB(88, 166, 255),
	togOn = Color3.fromRGB(52, 211, 153),
	togOff = Color3.fromRGB(51, 65, 85),
	input = Color3.fromRGB(15, 23, 42),
	fly = Color3.fromRGB(125, 211, 252),
	ghost = Color3.fromRGB(196, 181, 253),
	demon = Color3.fromRGB(239, 68, 68),
	gold = Color3.fromRGB(250, 204, 21),
	soul = Color3.fromRGB(167, 243, 208),
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â±ï¸ TWEEN INFO PRESETS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local TI = {
	f = TweenInfo.new(0.08, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
	s = TweenInfo.new(0.18, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
	o = TweenInfo.new(0.32, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
	c = TweenInfo.new(0.14, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
	b = TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
	smooth = TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’¾ STATE MANAGEMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ST = {
	-- UI
	open = true, 
	tab = 1, 
	
	-- Teleport
	tping = false, 
	lastTP = 0,
	tpHistory = {},
	
	-- Fly System
	fly = false, 
	flyMode = 1, -- 1=Normal, 2=Sonic, 3=Teleport, 4=God
	flyConn = nil, 
	flySpeed = 100, 
	flyAnimTrack = nil,
	
	-- Ghost/Soul System
	ghost = false,
	ghostMode = 1, -- 1=Soul, 2=Phantom, 3=Wraith
	ghostBodyClone = nil,
	ghostOrigTrans = {},
	ghostOrigHealth = nil,
	ghostConns = {},
	soulTrail = true,
	
	-- Demon System
	demon = false,
	demonStage = 1, -- 1=Normal, 2=Awakened, 3=Mythical
	demonConns = {},
	
	-- Other Features
	infJump = false, 
	jumpConn = nil,
	ws = 16, 
	wsActive = false,
	autoHeal = false,
	autoHealConn = nil,
	antiFall = true,
	
	-- Premium Features
	soulReturnKey = Enum.KeyCode.R,
	quickTpKey = Enum.KeyCode.T,
	flyToggleKey = Enum.KeyCode.F,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ› ï¸ UTILITY FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function mk(cl, pr, ch)
	local i = Instance.new(cl)
	for k, v in pairs(pr) do i[k] = v end
	if ch then for _, x in ipairs(ch) do x.Parent = i end end
	return i
end

local function rnd(p, r) 
	return mk("UICorner", {CornerRadius = UDim.new(0, r or 8), Parent = p}) 
end

local function stk(p, c, t) 
	return mk("UIStroke", {
		Color = c or C.stroke, 
		Thickness = t or 1.5, 
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		Parent = p
	}) 
end

local function pad(p, t, b, l, r) 
	return mk("UIPadding", {
		PaddingTop = UDim.new(0, t or 0), 
		PaddingBottom = UDim.new(0, b or 0), 
		PaddingLeft = UDim.new(0, l or 0), 
		PaddingRight = UDim.new(0, r or 0), 
		Parent = p
	}) 
end

local function tw(o, i, p) 
	return TweenService:Create(o, i, p) 
end

local function press(b) 
	local s = b.Size 
	tw(b, TI.f, {Size = UDim2.new(s.X.Scale, s.X.Offset - 3, s.Y.Scale, s.Y.Offset - 2)}):Play() 
	task.delay(0.06, function() 
		tw(b, TI.b, {Size = s}):Play() 
	end) 
end

local function getRoot()
	local ch = LP.Character
	return ch and ch:FindFirstChild("HumanoidRootPart"), ch and ch:FindFirstChild("Humanoid"), ch
end

local function playSFX(id, volume, pitch)
	pcall(function()
		local root = getRoot()
		if not root then return end
		local s = Instance.new("Sound")
		s.SoundId = "rbxassetid://" .. id
		s.Volume = volume or 0.5
		s.PlaybackSpeed = pitch or 1
		s.Parent = root
		s.PlayOnRemove = true
		s:Destroy()
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”¤ VIETNAMESE DIACRITICS REMOVER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function removeViDiacritics(str)
	local map = {
		["Ã "]="a",["Ã¡"]="a",["áº£"]="a",["Ã£"]="a",["áº¡"]="a",
		["Äƒ"]="a",["áº±"]="a",["áº¯"]="a",["áº³"]="a",["áºµ"]="a",["áº·"]="a",
		["Ã¢"]="a",["áº§"]="a",["áº¥"]="a",["áº©"]="a",["áº«"]="a",["áº­"]="a",
		["Ã¨"]="e",["Ã©"]="e",["áº»"]="e",["áº½"]="e",["áº¹"]="e",
		["Ãª"]="e",["á»"]="e",["áº¿"]="e",["á»ƒ"]="e",["á»…"]="e",["á»‡"]="e",
		["Ã¬"]="i",["Ã­"]="i",["á»‰"]="i",["Ä©"]="i",["á»‹"]="i",
		["Ã²"]="o",["Ã³"]="o",["á»"]="o",["Ãµ"]="o",["á»"]="o",
		["Ã´"]="o",["á»“"]="o",["á»‘"]="o",["á»•"]="o",["á»—"]="o",["á»™"]="o",
		["Æ¡"]="o",["á»"]="o",["á»›"]="o",["á»Ÿ"]="o",["á»¡"]="o",["á»£"]="o",
		["Ã¹"]="u",["Ãº"]="u",["á»§"]="u",["Å©"]="u",["á»¥"]="u",
		["Æ°"]="u",["á»«"]="u",["á»©"]="u",["á»­"]="u",["á»¯"]="u",["á»±"]="u",
		["á»³"]="y",["Ã½"]="y",["á»·"]="y",["á»¹"]="y",["á»µ"]="y",
		["Ä‘"]="d",
		["Ã€"]="A",["Ã"]="A",["áº¢"]="A",["Ãƒ"]="A",["áº "]="A",
		["Ä‚"]="A",["áº°"]="A",["áº®"]="A",["áº²"]="A",["áº´"]="A",["áº¶"]="A",
		["Ã‚"]="A",["áº¦"]="A",["áº¤"]="A",["áº¨"]="A",["áºª"]="A",["áº¬"]="A",
		["Ãˆ"]="E",["Ã‰"]="E",["áºº"]="E",["áº¼"]="E",["áº¸"]="E",
		["ÃŠ"]="E",["á»€"]="E",["áº¾"]="E",["á»‚"]="E",["á»„"]="E",["á»†"]="E",
		["ÃŒ"]="I",["Ã"]="I",["á»ˆ"]="I",["Ä¨"]="I",["á»Š"]="I",
		["Ã’"]="O",["Ã“"]="O",["á»"]="O",["Ã•"]="O",["á»Œ"]="O",
		["Ã”"]="O",["á»’"]="O",["á»"]="O",["á»”"]="O",["á»–"]="O",["á»˜"]="O",
		["Æ "]="O",["á»œ"]="O",["á»š"]="O",["á»"]="O",["á» "]="O",["á»¢"]="O",
		["Ã™"]="U",["Ãš"]="U",["á»¦"]="U",["Å¨"]="U",["á»¤"]="U",
		["Æ¯"]="U",["á»ª"]="U",["á»¨"]="U",["á»¬"]="U",["á»®"]="U",["á»°"]="U",
		["á»²"]="Y",["Ã"]="Y",["á»¶"]="Y",["á»¸"]="Y",["á»´"]="Y",
		["Ä"]="D",
	}
	local result = ""
	for i = 1, #str do
		local ch = str:sub(i, i)
		result = result .. (map[ch] or ch)
	end
	return result
end

local function translateQuery(input)
	local cleaned = removeViDiacritics(input):lower():gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")
	for vi, en in pairs(ViToEn) do
		if cleaned:find(vi, 1, true) then return en end
	end
	return cleaned
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ” SMART SEARCH SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function fuzzyMatch(a, b)
	a, b = a:lower(), b:lower()
	if a == b then return 1 end
	if b:find(a, 1, true) then return 0.95 end
	if a:find(b, 1, true) then return 0.9 end
	
	local matched = 0
	local aIdx = 1
	for i = 1, #b do
		if aIdx <= #a and b:sub(i, i) == a:sub(aIdx, aIdx) then
			matched = matched + 1
			aIdx = aIdx + 1
		end
	end
	return matched / math.max(#a, 1)
end

local function deepSearch(parent, query, results, depth)
	if depth > 10 or #results >= 40 then return end
	
	pcall(function()
		for _, child in pairs(parent:GetChildren()) do
			local score = fuzzyMatch(query, removeViDiacritics(child.Name))
			if score >= 0.3 then
				local part = child:FindFirstChild("HumanoidRootPart") or 
				             child:FindFirstChild("Head") or 
				             child:FindFirstChild("Torso") or 
				             child:FindFirstChild("UpperTorso") or
				             (child:IsA("BasePart") and child) or 
				             child:FindFirstChildWhichIsA("BasePart", true)
				
				if part and part:IsA("BasePart") then
					local isPlayer = false
					for _, plr in pairs(Players:GetPlayers()) do 
						if plr.Character == child then 
							isPlayer = true 
							break 
						end 
					end
					
					if not isPlayer then
						table.insert(results, {
							name = child.Name, 
							part = part, 
							model = child, 
							score = score, 
							hasHum = child:FindFirstChildOfClass("Humanoid") ~= nil,
							dist = 0
						})
					end
				end
			end
			
			if (child:IsA("Model") or child:IsA("Folder") or child:IsA("WorldModel")) and 
			   not child:IsA("Camera") and child.Name ~= "Terrain" then
				deepSearch(child, query, results, depth + 1)
			end
		end
	end)
end

local function smartSearch(rawQuery)
	local enQuery = translateQuery(rawQuery)
	local results = {}
	
	deepSearch(Workspace, enQuery, results, 0)
	
	local commonFolders = {"NPCs", "Map", "Enemies", "Bosses", "Locations", "Islands", "Shops", "Quests", "Live"}
	for _, folderName in ipairs(commonFolders) do
		local folder = Workspace:FindFirstChild(folderName)
		if folder then
			deepSearch(folder, enQuery, results, 0)
		end
	end
	
	if #results < 8 then
		local cleaned = removeViDiacritics(rawQuery):lower()
		if cleaned ~= enQuery then 
			deepSearch(Workspace, cleaned, results, 0) 
		end
	end
	
	local seen = {}
	local unique = {}
	for _, r in ipairs(results) do
		local key = r.name .. tostring(r.part)
		if not seen[key] then 
			seen[key] = true 
			table.insert(unique, r) 
		end
	end
	
	local root = getRoot()
	if root then
		for _, r in ipairs(unique) do
			r.dist = (r.part.Position - root.Position).Magnitude
		end
	end
	
	table.sort(unique, function(a, b)
		if math.abs(a.score - b.score) > 0.15 then return a.score > b.score end
		return a.dist < b.dist
	end)
	
	return unique
end

local function searchIsland(rawQuery)
	local enQuery = translateQuery(rawQuery)
	local best, bestScore = nil, 0
	for _, isl in ipairs(Islands) do
		local s = fuzzyMatch(enQuery, isl.N:lower())
		if s > bestScore then bestScore = s best = isl end
	end
	if bestScore >= 0.35 then return best end
	return nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸš€ ADVANCED TELEPORT SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function safeTp(pos, instant)
	if ST.tping or tick() - ST.lastTP < 0.25 then return false end
	
	local root, hum = getRoot()
	if not root or not hum then return false end
	
	ST.tping = true
	ST.lastTP = tick()
	
	local success = false
	pcall(function()
		if hum.Sit or hum.SeatPart then 
			hum.Sit = false 
			task.wait(0.12)
		end
		
		root.Anchored = true
		task.wait(0.04)
		
		root.AssemblyLinearVelocity = Vector3.zero
		root.AssemblyAngularVelocity = Vector3.zero
		
		if instant then
			root.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
		else
			local dist = (pos - root.Position).Magnitude
			local steps = math.clamp(math.floor(dist / 150), 1, 5)
			
			for i = 1, steps do
				local alpha = i / steps
				local newPos = root.Position:Lerp(pos, alpha)
				root.CFrame = CFrame.new(newPos + Vector3.new(0, 3, 0))
				task.wait(0.05)
			end
		end
		
		task.wait(0.06)
		
		root.AssemblyLinearVelocity = Vector3.zero
		root.AssemblyAngularVelocity = Vector3.zero
		root.Anchored = false
		
		playSFX(6895079853, 0.4, 1.4)
		
		table.insert(ST.tpHistory, 1, {pos = pos, time = tick()})
		if #ST.tpHistory > 10 then
			table.remove(ST.tpHistory)
		end
		
		success = true
	end)
	
	ST.tping = false
	return success
end

local function tpFaceNPC(npcPart)
	local root = getRoot()
	if not root or not npcPart then return false end
	
	local success = false
	pcall(function()
		local npcPos = npcPart.Position
		local dir = (root.Position - npcPos)
		dir = Vector3.new(dir.X, 0, dir.Z)
		
		if dir.Magnitude < 0.1 then 
			dir = Vector3.new(0, 0, 1) 
		end
		dir = dir.Unit
		
		local targetPos = npcPos + dir * 7
		targetPos = Vector3.new(targetPos.X, npcPos.Y + 1, targetPos.Z)
		
		if safeTp(targetPos) then
			task.wait(0.08)
			local r2 = getRoot()
			if r2 then 
				r2.CFrame = CFrame.lookAt(r2.Position, Vector3.new(npcPos.X, r2.Position.Y, npcPos.Z))
			end
			success = true
		end
	end)
	
	return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœˆï¸ ADVANCED FLY SYSTEM - 4 MODES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startFly()
	local root, hum, char = getRoot()
	if not root or not hum then return end
	
	stopFly()
	
	local flySpeed = ST.flySpeed
	local flyVelocity = Vector3.zero
	local flying = true
	
	-- Animation
	local flyAnim = nil
	pcall(function()
		local anim = Instance.new("Animation")
		anim.AnimationId = ST.flyMode == 4 and "rbxassetid://507767714" or "rbxassetid://507767515"
		local animator = hum:FindFirstChildOfClass("Animator")
		if animator then
			flyAnim = animator:LoadAnimation(anim)
		else
			flyAnim = hum:LoadAnimation(anim)
		end
		flyAnim.Priority = Enum.AnimationPriority.Action4
		flyAnim.Looped = true
		flyAnim:Play()
	end)
	
	ST.flyAnimTrack = flyAnim
	
	-- Fly trail for Sonic mode
	local trail = nil
	if ST.flyMode == 2 then
		pcall(function()
			local att0 = mk("Attachment", {Parent = root})
			local att1 = mk("Attachment", {Parent = root, Position = Vector3.new(0, -2, 0)})
			trail = mk("Trail", {
				Attachment0 = att0,
				Attachment1 = att1,
				Color = ColorSequence.new(C.cyan),
				Transparency = NumberSequence.new{
					NumberSequenceKeypoint.new(0, 0.5),
					NumberSequenceKeypoint.new(1, 1)
				},
				Lifetime = 0.5,
				MinLength = 0.1,
				LightEmission = 1,
				Parent = root
			})
		end)
	end
	
	-- Main fly loop
	ST.flyConns = ST.flyConns or {}
	ST.flyConns[1] = RunService.Heartbeat:Connect(function(dt)
		if not ST.fly or not flying then return end
		
		local r, h, ch = getRoot()
		if not r or not h or not ch then return end
		
		local cam = Workspace.CurrentCamera
		if not cam then return end
		
		local moveDir = Vector3.zero
		
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then 
			moveDir = moveDir + cam.CFrame.LookVector 
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then 
			moveDir = moveDir - cam.CFrame.LookVector 
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then 
			moveDir = moveDir - cam.CFrame.RightVector 
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then 
			moveDir = moveDir + cam.CFrame.RightVector 
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.Space) then 
			moveDir = moveDir + Vector3.new(0, 1, 0)
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then 
			moveDir = moveDir - Vector3.new(0, 1, 0)
		end
		
		-- Speed calculation based on mode
		local speed = flySpeed
		if ST.flyMode == 2 then speed = speed * 2 end -- Sonic
		if ST.flyMode == 4 then speed = speed * 3 end -- God
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then 
			speed = speed * 2.5 
		end
		
		-- Smooth movement
		if moveDir.Magnitude > 0 then
			flyVelocity = moveDir.Unit * speed
		else
			flyVelocity = flyVelocity * 0.88
		end
		
		-- Movement method based on mode
		pcall(function()
			if ST.flyMode == 3 then
				-- Teleport mode - instant short jumps
				if moveDir.Magnitude > 0 and tick() % 0.2 < dt then
					r.CFrame = r.CFrame + (flyVelocity * 0.5)
				end
			else
				-- Normal/Sonic/God - smooth CFrame movement
				r.CFrame = r.CFrame + (flyVelocity * dt)
			end
			
			r.AssemblyLinearVelocity = Vector3.zero
			r.AssemblyAngularVelocity = Vector3.zero
		end)
		
		-- Noclip
		for _, part in pairs(ch:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
		
		h.PlatformStand = true
	end)
	
	playSFX(6026984224, 0.3, 1.2)
end

local function stopFly()
	if ST.flyConns then
		for _, conn in pairs(ST.flyConns) do
			if conn then conn:Disconnect() end
		end
		ST.flyConns = {}
	end
	
	local root, hum = getRoot()
	
	if hum then 
		hum.PlatformStand = false 
	end
	
	if ST.flyAnimTrack then 
		pcall(function() 
			ST.flyAnimTrack:Stop() 
			ST.flyAnimTrack:Destroy() 
		end) 
		ST.flyAnimTrack = nil 
	end
	
	-- Remove trail
	if root then
		for _, child in pairs(root:GetChildren()) do
			if child:IsA("Trail") or child:IsA("Attachment") then
				child:Destroy()
			end
		end
	end
	
	local char = LP.Character
	if char then
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				part.CanCollide = true
			end
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ‘» ASTRAL PROJECTION SYSTEM - 3 GHOST MODES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function createSoulTrail(root)
	if not ST.soulTrail then return end
	
	pcall(function()
		local att0 = mk("Attachment", {Name = "SoulTrailAtt0", Parent = root})
		local att1 = mk("Attachment", {Name = "SoulTrailAtt1", Parent = root, Position = Vector3.new(0, -2, 0)})
		
		local trail = mk("Trail", {
			Name = "SoulTrail",
			Attachment0 = att0,
			Attachment1 = att1,
			Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, C.soul),
				ColorSequenceKeypoint.new(1, C.ghost)
			},
			Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.3),
				NumberSequenceKeypoint.new(1, 1)
			},
			Lifetime = 1,
			MinLength = 0.1,
			LightEmission = 0.9,
			Parent = root
		})
	end)
end

local function startGhost()
	local root, hum, char = getRoot()
	if not root or not hum or not char then return end
	
	stopGhost()
	
	ST.ghostOrigTrans = {}
	ST.ghostOrigHealth = hum.MaxHealth
	ST.ghostConns = {}
	
	-- ğŸ”¥ STEP 1: CREATE MEDITATING BODY (Clone stays at original position)
	pcall(function()
		local bodyClone = char:Clone()
		
		for _, d in pairs(bodyClone:GetDescendants()) do
			if d:IsA("Script") or d:IsA("LocalScript") or d:IsA("ModuleScript") then 
				d:Destroy() 
			end
		end
		
		local cloneHum = bodyClone:FindFirstChildOfClass("Humanoid")
		if cloneHum then
			cloneHum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
			cloneHum.HealthDisplayType = Enum.HumanoidHealthDisplayType.DisplayWhenDamaged
			cloneHum.PlatformStand = true
			cloneHum.Health = cloneHum.MaxHealth
		end
		
		local cloneRoot = bodyClone:FindFirstChild("HumanoidRootPart")
		if cloneRoot then
			cloneRoot.Anchored = true
			cloneRoot.CanCollide = false
			
			-- Meditation pose animation
			pcall(function()
				local anim = Instance.new("Animation")
				anim.AnimationId = "rbxassetid://3695333486" -- Meditation pose
				if cloneHum then
					local track = cloneHum:LoadAnimation(anim)
					track:Play()
				end
			end)
		end
		
		for _, p in pairs(bodyClone:GetDescendants()) do
			if p:IsA("BasePart") then 
				p.Anchored = true
				p.CanCollide = false
			end
		end
		
		-- Mode-specific body effects
		if ST.ghostMode == 1 then
			-- Soul mode - golden meditation aura
			if cloneRoot then
				local att = mk("Attachment", {Name = "MeditationAura", Parent = cloneRoot})
				mk("ParticleEmitter", {
					Color = ColorSequence.new(C.gold),
					Size = NumberSequence.new{NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(1, 0)},
					Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 1)},
					Lifetime = NumberRange.new(1.5, 2.5),
					Rate = 25,
					Speed = NumberRange.new(1, 2.5),
					SpreadAngle = Vector2.new(360, 360),
					Acceleration = Vector3.new(0, 3, 0),
					LightEmission = 0.7,
					Parent = att,
				})
				mk("PointLight", {
					Name = "MeditationLight",
					Color = C.gold,
					Brightness = 1.5,
					Range = 12,
					Parent = cloneRoot
				})
			end
		elseif ST.ghostMode == 2 then
			-- Phantom mode - dim the body
			for _, p in pairs(bodyClone:GetDescendants()) do
				if p:IsA("BasePart") then
					p.Transparency = math.min(p.Transparency + 0.5, 0.95)
				end
			end
		elseif ST.ghostMode == 3 then
			-- Wraith mode - dark shadow
			for _, p in pairs(bodyClone:GetDescendants()) do
				if p:IsA("BasePart") then
					p.Color = Color3.fromRGB(20, 20, 20)
					p.Material = Enum.Material.SmoothPlastic
				end
			end
		end
		
		bodyClone.Name = "AstralBody_" .. LP.UserId
		bodyClone.Parent = Workspace
		ST.ghostBodyClone = bodyClone
	end)
	
	-- ğŸ”¥ STEP 2: TRANSFORM REAL CHARACTER INTO SOUL
	pcall(function()
		local transparency = ST.ghostMode == 1 and 0.90 or (ST.ghostMode == 2 and 0.95 or 0.85)
		local soulColor = ST.ghostMode == 1 and C.soul or (ST.ghostMode == 2 and C.ghost or Color3.fromRGB(50, 50, 70))
		
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") then
				ST.ghostOrigTrans[p] = p.Transparency
				p.Transparency = transparency
				p.Color = soulColor
			elseif p:IsA("Decal") then
				ST.ghostOrigTrans[p] = p.Transparency
				p.Transparency = 0.98
			end
		end
		
		for _, acc in pairs(char:GetChildren()) do
			if acc:IsA("Accessory") then
				local handle = acc:FindFirstChild("Handle")
				if handle then
					ST.ghostOrigTrans[handle] = handle.Transparency
					handle.Transparency = transparency
				end
			end
		end
	end)
	
	-- ğŸ”¥ STEP 3: SOUL VISUAL EFFECTS
	pcall(function()
		local att = mk("Attachment", {Name = "SoulAura", Parent = root})
		
		-- Main soul particle
		mk("ParticleEmitter", {
			Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, ST.ghostMode == 1 and C.soul or (ST.ghostMode == 2 and C.ghost or Color3.fromRGB(80, 80, 100))),
				ColorSequenceKeypoint.new(0.5, ST.ghostMode == 1 and C.ghost or C.purple),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 150)),
			},
			Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 2),
				NumberSequenceKeypoint.new(0.5, 1.2),
				NumberSequenceKeypoint.new(1, 0)
			},
			Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.5),
				NumberSequenceKeypoint.new(1, 1)
			},
			Texture = "rbxasset://textures/particles/smoke_main.dds",
			Lifetime = NumberRange.new(1, 1.8),
			Rate = ST.ghostMode == 3 and 60 or 45,
			Speed = NumberRange.new(1.5, 3.5),
			SpreadAngle = Vector2.new(360, 360),
			Acceleration = Vector3.new(0, 2.5, 0),
			LightEmission = 0.85,
			Parent = att,
		})
		
		-- Sparkle particles
		mk("ParticleEmitter", {
			Color = ColorSequence.new(Color3.fromRGB(200, 230, 255)),
			Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.25),
				NumberSequenceKeypoint.new(1, 0)
			},
			Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(1, 1)
			},
			Lifetime = NumberRange.new(0.6, 1.2),
			Rate = 35,
			Speed = NumberRange.new(2.5, 5),
			SpreadAngle = Vector2.new(25, 25),
			LightEmission = 1,
			Parent = att,
		})
		
		mk("PointLight", {
			Name = "SoulLight",
			Color = ST.ghostMode == 1 and C.soul or (ST.ghostMode == 2 and C.ghost or Color3.fromRGB(100, 100, 150)),
			Brightness = 3,
			Range = ST.ghostMode == 3 and 20 or 14,
			Parent = root
		})
		
		-- Create soul trail
		createSoulTrail(root)
	end)
	
	-- ğŸ”¥ STEP 4: GOD MODE + NOCLIP
	ST.ghostConns[1] = RunService.Stepped:Connect(function()
		local ch = LP.Character
		if not ch then return end
		
		local h = ch:FindFirstChildOfClass("Humanoid")
		if h then
			-- Stealth god mode
			if h.Health < h.MaxHealth * 0.98 then
				h.Health = h.MaxHealth
			end
			h.PlatformStand = false
		end
		
		-- Noclip
		for _, p in pairs(ch:GetDescendants()) do
			if p:IsA("BasePart") then
				p.CanCollide = false
			end
		end
	end)
	
	-- ğŸ”¥ STEP 5: CONTINUOUS HEALING
	ST.ghostConns[2] = RunService.Heartbeat:Connect(function()
		local ch = LP.Character
		if not ch then return end
		
		local h = ch:FindFirstChildOfClass("Humanoid")
		if h then
			local targetHealth = h.MaxHealth
			if h.Health < targetHealth then
				h.Health = targetHealth
			end
		end
	end)
	
	-- ğŸ”¥ STEP 6: LIGHT PULSING EFFECT
	ST.ghostConns[3] = RunService.Heartbeat:Connect(function()
		if not ST.ghost then return end
		
		local r = getRoot()
		if not r then return end
		
		local soulLight = r:FindFirstChild("SoulLight")
		if soulLight then
			local time = tick()
			soulLight.Brightness = 2.6 + math.sin(time * 3.5) * 0.6
			soulLight.Range = 13 + math.sin(time * 3) * 2.5
		end
	end)
	
	playSFX(1837829565, 0.5, 0.9)
end

local function stopGhost()
	-- Disconnect all ghost connections
	if ST.ghostConns then
		for _, conn in pairs(ST.ghostConns) do
			if conn then conn:Disconnect() end
		end
		ST.ghostConns = {}
	end
	
	-- Destroy meditating body
	if ST.ghostBodyClone then 
		ST.ghostBodyClone:Destroy() 
		ST.ghostBodyClone = nil 
	end
	
	local char = LP.Character
	if char then
		local hum = char:FindFirstChildOfClass("Humanoid")
		
		-- Restore health
		if hum and ST.ghostOrigHealth then
			hum.MaxHealth = ST.ghostOrigHealth
			hum.Health = ST.ghostOrigHealth
		end
		
		-- Restore transparency and color
		for obj, trans in pairs(ST.ghostOrigTrans) do
			if obj and obj.Parent then
				pcall(function() 
					obj.Transparency = trans
				end)
			end
		end
		
		-- Restore original colors
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
				p.CanCollide = true
				
				local bodyColors = char:FindFirstChildOfClass("BodyColors")
				if bodyColors then
					if p.Name:find("Torso") or p.Name == "UpperTorso" or p.Name == "LowerTorso" then
						p.Color = bodyColors.TorsoColor3
					elseif p.Name:find("Head") then
						p.Color = bodyColors.HeadColor3
					elseif p.Name:find("Arm") then
						p.Color = bodyColors.LeftArmColor3
					elseif p.Name:find("Leg") then
						p.Color = bodyColors.LeftLegColor3
					end
				end
			end
		end
		
		-- Remove soul effects
		local root = char:FindFirstChild("HumanoidRootPart")
		if root then
			local att = root:FindFirstChild("SoulAura")
			if att then att:Destroy() end
			
			local light = root:FindFirstChild("SoulLight")
			if light then light:Destroy() end
			
			-- Remove trail
			for _, child in pairs(root:GetChildren()) do
				if child.Name:find("SoulTrail") then
					child:Destroy()
				end
			end
		end
	end
	
	ST.ghostOrigTrans = {}
	ST.ghostOrigHealth = nil
	
	playSFX(1837829565, 0.4, 1.1)
end

-- Quick return to body function
local function returnToBody()
	if not ST.ghost or not ST.ghostBodyClone then return end
	
	local bodyRoot = ST.ghostBodyClone:FindFirstChild("HumanoidRootPart")
	if bodyRoot then
		safeTp(bodyRoot.Position, true)
		playSFX(6026984224, 0.4, 1.5)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ˜ˆ DEMON V4 AWAKENING - 3 STAGES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function startDemon()
	local root, hum, char = getRoot()
	if not root or not hum or not char then return end
	
	stopDemon()
	
	ST.demonConns = {}
	
	-- Scream animation
	local screamAnim = nil
	pcall(function()
		local a = Instance.new("Animation")
		a.AnimationId = "rbxassetid://507770677"
		local animator = hum:FindFirstChildOfClass("Animator")
		if animator then
			screamAnim = animator:LoadAnimation(a)
		else
			screamAnim = hum:LoadAnimation(a)
		end
		screamAnim.Priority = Enum.AnimationPriority.Action4
		screamAnim:Play()
	end)
	
	-- Sound effect
	playSFX(262562442, 0.8, 0.7 + (ST.demonStage * 0.1))
	
	task.wait(1.4)
	if screamAnim then 
		pcall(function() screamAnim:Stop() end) 
	end
	
	-- Transform character color based on stage
	pcall(function()
		local demonColors = {
			Color3.fromRGB(100, 0, 0), -- Stage 1: Dark red
			Color3.fromRGB(60, 0, 0),  -- Stage 2: Darker red
			Color3.fromRGB(20, 0, 0),  -- Stage 3: Almost black
		}
		
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
				p.Color = demonColors[ST.demonStage]
				p.Material = Enum.Material.Neon
			end
		end
	end)
	
	-- Create demon aura
	local att = mk("Attachment", {Name = "DemonAura", Parent = root})
	
	-- Fire particles (intensity based on stage)
	local fireRate = 80 + (ST.demonStage * 40)
	mk("ParticleEmitter", {
		Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(150, 0, 0)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 0, 0)),
		},
		Size = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 3 + ST.demonStage),
			NumberSequenceKeypoint.new(0.5, 1.5 + ST.demonStage * 0.5),
			NumberSequenceKeypoint.new(1, 0)
		},
		Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 0.2),
			NumberSequenceKeypoint.new(1, 1)
		},
		Texture = "rbxasset://textures/particles/fire_main.dds",
		Lifetime = NumberRange.new(0.6, 1.3),
		Rate = fireRate,
		Speed = NumberRange.new(3 + ST.demonStage, 6 + ST.demonStage * 2),
		SpreadAngle = Vector2.new(30, 30),
		Acceleration = Vector3.new(0, 5 + ST.demonStage, 0),
		RotSpeed = NumberRange.new(-200, 200),
		LightEmission = 0.9,
		LightInfluence = 0.1,
		Parent = att,
	})
	
	-- Smoke
	mk("ParticleEmitter", {
		Color = ColorSequence.new(Color3.fromRGB(30 - ST.demonStage * 5, 0, 0)),
		Size = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 4 + ST.demonStage),
			NumberSequenceKeypoint.new(1, 1)
		},
		Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 0.4),
			NumberSequenceKeypoint.new(1, 1)
		},
		Texture = "rbxasset://textures/particles/smoke_main.dds",
		Lifetime = NumberRange.new(1, 2),
		Rate = 35 + ST.demonStage * 15,
		Speed = NumberRange.new(1, 4),
		SpreadAngle = Vector2.new(360, 360),
		Acceleration = Vector3.new(0, 3, 0),
		LightEmission = 0.3,
		Parent = att,
	})
	
	-- Sparks
	mk("ParticleEmitter", {
		Color = ColorSequence.new(Color3.fromRGB(255, 50 + ST.demonStage * 20, 0)),
		Size = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 0.3 + ST.demonStage * 0.1),
			NumberSequenceKeypoint.new(1, 0)
		},
		Transparency = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 1)
		},
		Lifetime = NumberRange.new(0.4, 0.9),
		Rate = 60 + ST.demonStage * 20,
		Speed = NumberRange.new(5 + ST.demonStage * 2, 10 + ST.demonStage * 3),
		SpreadAngle = Vector2.new(20, 20),
		LightEmission = 1,
		Parent = att,
	})
	
	-- Stage 3: Additional skull particles
	if ST.demonStage == 3 then
		mk("ParticleEmitter", {
			Texture = "rbxasset://textures/particles/sparkles_main.dds",
			Color = ColorSequence.new(Color3.fromRGB(150, 0, 0)),
			Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 2),
				NumberSequenceKeypoint.new(1, 0)
			},
			Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.3),
				NumberSequenceKeypoint.new(1, 1)
			},
			Lifetime = NumberRange.new(1.5, 2.5),
			Rate = 25,
			Speed = NumberRange.new(3, 6),
			SpreadAngle = Vector2.new(360, 360),
			Rotation = NumberRange.new(0, 360),
			RotSpeed = NumberRange.new(-100, 100),
			LightEmission = 0.8,
			Parent = att,
		})
	end
	
	-- Demon light
	local light = mk("PointLight", {
		Name = "DemonLight",
		Color = Color3.fromRGB(255, 0, 0),
		Brightness = 3 + ST.demonStage,
		Range = 20 + ST.demonStage * 8,
		Parent = root
	})
	
	-- Pulsing effect
	ST.demonConns[1] = RunService.Heartbeat:Connect(function()
		if not ST.demon then return end
		
		local r = getRoot()
		if not r then return end
		
		local time = tick()
		local intensity = ST.demonStage
		light.Brightness = (3 + intensity) + math.sin(time * (4 + intensity)) * (1 + intensity * 0.5)
		light.Range = (20 + intensity * 8) + math.sin(time * (3 + intensity)) * (4 + intensity * 2)
	end)
	
	-- Stage 2+: Lightning effects
	if ST.demonStage >= 2 then
		ST.demonConns[2] = RunService.Heartbeat:Connect(function()
			if math.random() < 0.02 then
				playSFX(821439273, 0.3, math.random(90, 110) / 100)
			end
		end)
	end
	
	-- Stage 3: Screen shake and color correction
	if ST.demonStage == 3 then
		pcall(function()
			local cc = Instance.new("ColorCorrectionEffect")
			cc.Name = "DemonCC"
			cc.Saturation = -0.3
			cc.TintColor = Color3.fromRGB(255, 200, 200)
			cc.Parent = Lighting
			
			ST.demonConns[3] = RunService.Heartbeat:Connect(function()
				local cam = Workspace.CurrentCamera
				if cam then
					cam.CFrame = cam.CFrame * CFrame.Angles(
						math.rad(math.random(-1, 1) * 0.5),
						math.rad(math.random(-1, 1) * 0.5),
						0
					)
				end
			end)
		end)
	end
end

local function stopDemon()
	-- Disconnect connections
	if ST.demonConns then
		for _, conn in pairs(ST.demonConns) do
			if conn then conn:Disconnect() end
		end
		ST.demonConns = {}
	end
	
	local root, _, char = getRoot()
	
	-- Remove effects
	if root then
		local att = root:FindFirstChild("DemonAura")
		if att then att:Destroy() end
		
		local lt = root:FindFirstChild("DemonLight")
		if lt then lt:Destroy() end
	end
	
	-- Remove color correction
	pcall(function()
		local cc = Lighting:FindFirstChild("DemonCC")
		if cc then cc:Destroy() end
	end)
	
	-- Restore colors
	if char then
		pcall(function()
			for _, p in pairs(char:GetDescendants()) do
				if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
					p.Material = Enum.Material.SmoothPlastic
					
					local bodyColors = char:FindFirstChildOfClass("BodyColors")
					if bodyColors then
						if p.Name:find("Torso") or p.Name == "UpperTorso" or p.Name == "LowerTorso" then
							p.Color = bodyColors.TorsoColor3
						elseif p.Name:find("Head") then
							p.Color = bodyColors.HeadColor3
						elseif p.Name:find("Arm") then
							p.Color = bodyColors.LeftArmColor3
						elseif p.Name:find("Leg") then
							p.Color = bodyColors.LeftLegColor3
						end
					else
						p.Color = Color3.fromRGB(163, 162, 165)
					end
				end
			end
		end)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¨ GUI CREATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local GUI = mk("ScreenGui", {
	Name = "FlashTPAlphaV4", 
	ResetOnSpawn = false, 
	ZIndexBehavior = Enum.ZIndexBehavior.Sibling, 
	IgnoreGuiInset = false
})

pcall(function() GUI.Parent = CoreGui end)
if not GUI.Parent then GUI.Parent = LP:WaitForChild("PlayerGui") end

-- Toggle button (minimized state)
local TogBtn = mk("TextButton", {
	Size = UDim2.new(0, 48, 0, 48), 
	Position = UDim2.new(0, 14, 0.5, -24), 
	BackgroundColor3 = C.accent, 
	Text = "âš¡", 
	TextSize = 20, 
	Font = Enum.Font.GothamBold, 
	TextColor3 = C.text, 
	AutoButtonColor = false, 
	Visible = false, 
	ZIndex = 10, 
	Parent = GUI
})
rnd(TogBtn, 24)
stk(TogBtn, C.accentH, 2)

-- Add glow effect to toggle button
mk("UIGradient", {
	Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, C.accent)
	},
	Rotation = 45,
	Parent = TogBtn
})

-- Main frame
local Main = mk("Frame", {
	Name = "Main", 
	Size = UDim2.new(0, 230, 0, 400), 
	Position = UDim2.new(0, 14, 0.5, -200), 
	BackgroundColor3 = C.bg, 
	BorderSizePixel = 0, 
	ClipsDescendants = true, 
	Parent = GUI
})
rnd(Main, 12)
stk(Main, C.stroke, 2)

-- Drop shadow effect
mk("ImageLabel", {
	Size = UDim2.new(1, 40, 1, 40),
	Position = UDim2.new(0, -20, 0, -20),
	BackgroundTransparency = 1,
	Image = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	ImageColor3 = Color3.fromRGB(0, 0, 0),
	ImageTransparency = 0.7,
	ScaleType = Enum.ScaleType.Slice,
	SliceCenter = Rect.new(10, 10, 118, 118),
	ZIndex = -1,
	Parent = Main
})

-- Title bar
local TBar = mk("Frame", {
	Size = UDim2.new(1, 0, 0, 38), 
	BackgroundColor3 = C.panel, 
	BorderSizePixel = 0, 
	Parent = Main
})
rnd(TBar, 12)
mk("Frame", {
	Size = UDim2.new(1, 0, 0, 12), 
	Position = UDim2.new(0, 0, 1, -12), 
	BackgroundColor3 = C.panel, 
	BorderSizePixel = 0, 
	Parent = TBar
})

-- Animated accent line
local al = mk("Frame", {
	Size = UDim2.new(1, 0, 0, 2), 
	Position = UDim2.new(0, 0, 1, 0), 
	BackgroundColor3 = C.accent, 
	BorderSizePixel = 0, 
	Parent = TBar
})
mk("UIGradient", {
	Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, C.accent),
		ColorSequenceKeypoint.new(0.5, C.accentH),
		ColorSequenceKeypoint.new(1, C.accent)
	},
	Rotation = 0, 
	Parent = al
})

-- Animate the gradient
task.spawn(function()
	while task.wait(0.03) do
		pcall(function()
			local gradient = al:FindFirstChildOfClass("UIGradient")
			if gradient then
				gradient.Rotation = (gradient.Rotation + 2) % 360
			end
		end)
	end
end)

-- Title text
mk("TextLabel", {
	Size = UDim2.new(1, -100, 1, 0), 
	Position = UDim2.new(0, 10, 0, 0), 
	BackgroundTransparency = 1, 
	Text = "âš¡ FLASH", 
	TextColor3 = C.text, 
	TextSize = 15, 
	Font = Enum.Font.GothamBlack, 
	TextXAlignment = Enum.TextXAlignment.Left, 
	Parent = TBar
})

-- Version badge
local vBadge = mk("TextLabel", {
	Size = UDim2.new(0, 38, 0, 16), 
	Position = UDim2.new(0, 70, 0.5, -8), 
	BackgroundColor3 = C.purple, 
	TextColor3 = C.text, 
	Text = "V4.0", 
	TextSize = 9, 
	Font = Enum.Font.GothamBold, 
	Parent = TBar
})
rnd(vBadge, 4)

-- VIP badge
local vipBadge = mk("TextLabel", {
	Size = UDim2.new(0, 32, 0, 16), 
	Position = UDim2.new(0, 112, 0.5, -8), 
	BackgroundColor3 = C.gold, 
	TextColor3 = C.bg, 
	Text = "VIP", 
	TextSize = 9, 
	Font = Enum.Font.GothamBold, 
	Parent = TBar
})
rnd(vipBadge, 4)

-- Close button
local XBtn = mk("TextButton", {
	Size = UDim2.new(0, 26, 0, 24), 
	Position = UDim2.new(1, -32, 0.5, -12), 
	BackgroundColor3 = C.card, 
	Text = "âœ•", 
	TextColor3 = C.dim, 
	TextSize = 12, 
	Font = Enum.Font.GothamBold, 
	AutoButtonColor = false, 
	Parent = TBar
})
rnd(XBtn, 6)
stk(XBtn, C.stroke, 1)

XBtn.MouseEnter:Connect(function() 
	tw(XBtn, TI.f, {BackgroundColor3 = C.red, TextColor3 = C.text}):Play() 
end)
XBtn.MouseLeave:Connect(function() 
	tw(XBtn, TI.f, {BackgroundColor3 = C.card, TextColor3 = C.dim}):Play() 
end)

-- Tab bar
local TabBar = mk("Frame", {
	Size = UDim2.new(1, -12, 0, 28), 
	Position = UDim2.new(0, 6, 0, 42), 
	BackgroundColor3 = C.tab, 
	BorderSizePixel = 0, 
	Parent = Main
})
rnd(TabBar, 6)
pad(TabBar, 3, 3, 3, 3)
stk(TabBar, C.stroke, 1)

mk("UIListLayout", {
	FillDirection = Enum.FillDirection.Horizontal, 
	Padding = UDim.new(0, 3), 
	HorizontalAlignment = Enum.HorizontalAlignment.Center, 
	VerticalAlignment = Enum.VerticalAlignment.Center, 
	Parent = TabBar
})

local tabs = {}
local pages = {}
local tabData = {
	{icon = "ğŸï¸", name = "Island"},
	{icon = "ğŸ”", name = "Search"},
	{icon = "âš™ï¸", name = "Powers"},
	{icon = "ğŸ¯", name = "Extra"}
}

for i, td in ipairs(tabData) do
	local tb = mk("TextButton", {
		Size = UDim2.new(0, 48, 0, 20), 
		BackgroundColor3 = i == 1 and C.tabA or C.card, 
		Text = td.icon, 
		TextColor3 = i == 1 and C.text or C.dim, 
		TextSize = 11, 
		Font = Enum.Font.GothamBold, 
		AutoButtonColor = false, 
		LayoutOrder = i, 
		Parent = TabBar
	})
	rnd(tb, 5)
	
	if i == 1 then
		stk(tb, C.accentH, 1.5)
	end
	
	tabs[i] = tb
end

-- Content area
local Content = mk("Frame", {
	Size = UDim2.new(1, 0, 1, -74), 
	Position = UDim2.new(0, 0, 0, 74), 
	BackgroundTransparency = 1, 
	ClipsDescendants = true, 
	Parent = Main
})

-- Status label
local SLbl = mk("TextLabel", {
	Size = UDim2.new(1, -12, 0, 16), 
	Position = UDim2.new(0, 6, 1, -18), 
	BackgroundTransparency = 1, 
	Text = "", 
	TextColor3 = C.green, 
	TextSize = 9, 
	Font = Enum.Font.GothamBold, 
	TextXAlignment = Enum.TextXAlignment.Left, 
	TextTransparency = 1, 
	ZIndex = 5, 
	Parent = Main
})

local function status(t, col) 
	SLbl.Text = t 
	SLbl.TextColor3 = col or C.green 
	tw(SLbl, TI.f, {TextTransparency = 0}):Play() 
	task.delay(3.5, function() 
		tw(SLbl, TI.s, {TextTransparency = 1}):Play() 
	end) 
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“„ PAGE 1: ISLAND TELEPORT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P1 = mk("ScrollingFrame", {
	Name = "P1", 
	Size = UDim2.new(1, -6, 1, -4), 
	Position = UDim2.new(0, 3, 0, 2), 
	BackgroundTransparency = 1, 
	ScrollBarThickness = 4, 
	ScrollBarImageColor3 = C.accent, 
	CanvasSize = UDim2.new(0, 0, 0, 0), 
	AutomaticCanvasSize = Enum.AutomaticSize.Y, 
	BorderSizePixel = 0, 
	Visible = true, 
	Parent = Content
})

mk("UIListLayout", {
	Padding = UDim.new(0, 4), 
	HorizontalAlignment = Enum.HorizontalAlignment.Center, 
	SortOrder = Enum.SortOrder.LayoutOrder, 
	Parent = P1
})
pad(P1, 3, 6, 0, 0)
pages[1] = P1

-- Search box
local islandSearch = mk("Frame", {
	Size = UDim2.new(1, -10, 0, 32), 
	BackgroundColor3 = C.input, 
	BorderSizePixel = 0, 
	LayoutOrder = 0, 
	Parent = P1
})
rnd(islandSearch, 7)
stk(islandSearch, C.stroke, 1.5)

mk("TextLabel", {
	Size = UDim2.new(0, 26, 1, 0), 
	Position = UDim2.new(0, 4, 0, 0), 
	BackgroundTransparency = 1, 
	Text = "ğŸ”", 
	TextSize = 13, 
	Parent = islandSearch
})

local islandInput = mk("TextBox", {
	Size = UDim2.new(1, -34, 1, 0), 
	Position = UDim2.new(0, 28, 0, 0), 
	BackgroundTransparency = 1, 
	PlaceholderText = "Search islands...", 
	PlaceholderColor3 = C.dim, 
	Text = "", 
	TextColor3 = C.text, 
	TextSize = 11, 
	Font = Enum.Font.GothamMedium, 
	TextXAlignment = Enum.TextXAlignment.Left, 
	ClearTextOnFocus = false, 
	Parent = islandSearch
})

-- Focus effects
islandInput.Focused:Connect(function()
	local s = islandSearch:FindFirstChildOfClass("UIStroke")
	if s then tw(s, TI.f, {Color = C.accent, Thickness = 2}):Play() end
end)

islandInput.FocusLost:Connect(function()
	local s = islandSearch:FindFirstChildOfClass("UIStroke")
	if s then tw(s, TI.f, {Color = C.stroke, Thickness = 1.5}):Play() end
end)

-- Island buttons
local islandBtns = {}
for i, loc in ipairs(Islands) do
	local btn = mk("Frame", {
		Size = UDim2.new(1, -10, 0, 34), 
		BackgroundColor3 = C.card, 
		BorderSizePixel = 0, 
		LayoutOrder = i, 
		Parent = P1
	})
	rnd(btn, 7)
	stk(btn, C.stroke, 1)
	
	-- Icon
	mk("TextLabel", {
		Size = UDim2.new(0, 24, 1, 0), 
		Position = UDim2.new(0, 6, 0, 0), 
		BackgroundTransparency = 1, 
		Text = loc.I, 
		TextSize = 14, 
		Parent = btn
	})
	
	-- Name
	mk("TextLabel", {
		Size = UDim2.new(1, -84, 1, -12), 
		Position = UDim2.new(0, 30, 0, 4), 
		BackgroundTransparency = 1, 
		Text = loc.N, 
		TextColor3 = C.text, 
		TextSize = 11, 
		Font = Enum.Font.GothamSemibold, 
		TextXAlignment = Enum.TextXAlignment.Left, 
		TextTruncate = Enum.TextTruncate.AtEnd, 
		Parent = btn
	})
	
	-- Type badge
	mk("TextLabel", {
		Size = UDim2.new(0, 40, 0, 14), 
		Position = UDim2.new(0, 30, 1, -16), 
		BackgroundColor3 = C.tab, 
		TextColor3 = C.dim, 
		Text = loc.T or "Island", 
		TextSize = 7, 
		Font = Enum.Font.GothamBold, 
		Parent = btn
	}, {rnd(btn, 3)})
	
	-- TP Button
	local tpBtn = mk("TextButton", {
		Size = UDim2.new(0, 46, 0, 26), 
		Position = UDim2.new(1, -52, 0.5, -13), 
		BackgroundColor3 = C.accent, 
		Text = "TP", 
		TextColor3 = C.text, 
		TextSize = 10, 
		Font = Enum.Font.GothamBold, 
		AutoButtonColor = false, 
		Parent = btn
	})
	rnd(tpBtn, 6)
	
	tpBtn.MouseEnter:Connect(function() 
		tw(tpBtn, TI.f, {BackgroundColor3 = C.accentH}):Play()
		tw(btn, TI.f, {BackgroundColor3 = C.cardH}):Play()
	end)
	
	tpBtn.MouseLeave:Connect(function() 
		tw(tpBtn, TI.f, {BackgroundColor3 = C.accent}):Play()
		tw(btn, TI.f, {BackgroundColor3 = C.card}):Play()
	end)
	
	tpBtn.MouseButton1Click:Connect(function()
		press(tpBtn)
		tw(btn, TI.f, {BackgroundColor3 = C.green}):Play()
		task.delay(0.15, function() 
			tw(btn, TI.s, {BackgroundColor3 = C.card}):Play() 
		end)
		
		if safeTp(loc.P) then 
			status("âœ“ Teleported to " .. loc.N, C.green) 
		else 
			status("âœ— Teleport failed", C.red) 
		end
	end)
	
	islandBtns[i] = {btn = btn, name = loc.N}
end

-- Search filtering
islandInput:GetPropertyChangedSignal("Text"):Connect(function()
	local q = translateQuery(islandInput.Text)
	for _, b in ipairs(islandBtns) do
		b.btn.Visible = q == "" or fuzzyMatch(q, b.name:lower()) >= 0.3
	end
end)

islandInput.FocusLost:Connect(function(enter)
	if enter and islandInput.Text ~= "" then
		local isl = searchIsland(islandInput.Text)
		if isl then
			if safeTp(isl.P) then 
				status("âœ“ " .. isl.N, C.green) 
			else 
				status("âœ— Failed", C.red) 
			end
		else
			status("âœ— Not found", C.red)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“„ PAGE 2: SMART SEARCH
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P2 = mk("Frame", {
	Name = "P2", 
	Size = UDim2.new(1, 0, 1, 0), 
	BackgroundTransparency = 1, 
	Visible = false, 
	Parent = Content
})
pages[2] = P2

-- Search box
local npcSrch = mk("Frame", {
	Size = UDim2.new(1, -12, 0, 32), 
	Position = UDim2.new(0, 6, 0, 4), 
	BackgroundColor3 = C.input, 
	BorderSizePixel = 0, 
	Parent = P2
})
rnd(npcSrch, 7)
stk(npcSrch, C.stroke, 1.5)

mk("TextLabel", {
	Size = UDim2.new(0, 26, 1, 0), 
	Position = UDim2.new(0, 4, 0, 0), 
	BackgroundTransparency = 1, 
	Text = "ğŸ”", 
	TextSize = 13, 
	Parent = npcSrch
})

local npcIn = mk("TextBox", {
	Size = UDim2.new(1, -66, 1, 0), 
	Position = UDim2.new(0, 28, 0, 0), 
	BackgroundTransparency = 1, 
	PlaceholderText = "NPC / Boss / Location...", 
	PlaceholderColor3 = C.dim, 
	Text = "", 
	TextColor3 = C.text, 
	TextSize = 11, 
	Font = Enum.Font.GothamMedium, 
	TextXAlignment = Enum.TextXAlignment.Left, 
	ClearTextOnFocus = false, 
	Parent = npcSrch
})

local goBtn = mk("TextButton", {
	Size = UDim2.new(0, 32, 0, 24), 
	Position = UDim2.new(1, -36, 0.5, -12), 
	BackgroundColor3 = C.accent, 
	Text = "GO", 
	TextColor3 = C.text, 
	TextSize = 10, 
	Font = Enum.Font.GothamBold, 
	AutoButtonColor = false, 
	Parent = npcSrch
})
rnd(goBtn, 5)

goBtn.MouseEnter:Connect(function() 
	tw(goBtn, TI.f, {BackgroundColor3 = C.accentH}):Play() 
end)
goBtn.MouseLeave:Connect(function() 
	tw(goBtn, TI.f, {BackgroundColor3 = C.accent}):Play() 
end)

-- Hint
mk("TextLabel", {
	Size = UDim2.new(1, -12, 0, 16), 
	Position = UDim2.new(0, 6, 0, 39), 
	BackgroundTransparency = 1, 
	Text = "âœ¨ AI-powered fuzzy search â€¢ VI/EN supported", 
	TextColor3 = C.dim, 
	TextSize = 8, 
	Font = Enum.Font.GothamMedium, 
	TextXAlignment = Enum.TextXAlignment.Left, 
	Parent = P2
})

-- Results scroll
local npcScroll = mk("ScrollingFrame", {
	Size = UDim2.new(1, -12, 1, -62), 
	Position = UDim2.new(0, 6, 0, 58), 
	BackgroundTransparency = 1, 
	ScrollBarThickness = 4, 
	ScrollBarImageColor3 = C.accent, 
	CanvasSize = UDim2.new(0, 0, 0, 0), 
	AutomaticCanvasSize = Enum.AutomaticSize.Y, 
	BorderSizePixel = 0, 
	Parent = P2
})

mk("UIListLayout", {
	Padding = UDim.new(0, 4), 
	HorizontalAlignment = Enum.HorizontalAlignment.Center, 
	SortOrder = Enum.SortOrder.LayoutOrder, 
	Parent = npcScroll
})
pad(npcScroll, 2, 4, 0, 0)

local npcInfoLbl = mk("TextLabel", {
	Size = UDim2.new(1, -8, 0, 20), 
	BackgroundTransparency = 1, 
	Text = "", 
	TextColor3 = C.dim, 
	TextSize = 10, 
	Font = Enum.Font.GothamMedium, 
	LayoutOrder = 0, 
	Parent = npcScroll
})

local function clearNPCR() 
	for _, c in pairs(npcScroll:GetChildren()) do 
		if c:IsA("Frame") or c:IsA("TextButton") then 
			c:Destroy() 
		end 
	end 
end

local function doNPCSearch()
	local q = npcIn.Text:gsub("^%s+", ""):gsub("%s+$", "")
	if #q < 2 then 
		status("âš  Min 2 characters", C.orange) 
		return 
	end
	
	clearNPCR()
	npcInfoLbl.Text = "ğŸ” Searching workspace..."
	npcInfoLbl.TextColor3 = C.orange

	task.defer(function()
		local isl = searchIsland(q)
		local results = smartSearch(q)
		
		if isl then
			local ib = mk("Frame", {
				Size = UDim2.new(1, -6, 0, 32), 
				BackgroundColor3 = C.cyan, 
				BorderSizePixel = 0, 
				LayoutOrder = 0, 
				Parent = npcScroll
			})
			rnd(ib, 6)
			
			mk("TextLabel", {
				Size = UDim2.new(0, 22, 1, 0), 
				Position = UDim2.new(0, 5, 0, 0), 
				BackgroundTransparency = 1, 
				Text = isl.I, 
				TextSize = 13, 
				Parent = ib
			})
			
			mk("TextLabel", {
				Size = UDim2.new(1, -72, 1, 0), 
				Position = UDim2.new(0, 26, 0, 0), 
				BackgroundTransparency = 1, 
				Text = "ğŸï¸ " .. isl.N, 
				TextColor3 = C.bg, 
				TextSize = 11, 
				Font = Enum.Font.GothamBold, 
				TextXAlignment = Enum.TextXAlignment.Left, 
				Parent = ib
			})
			
			local islBtn = mk("TextButton", {
				Size = UDim2.new(0, 40, 0, 24), 
				Position = UDim2.new(1, -46, 0.5, -12), 
				BackgroundColor3 = C.bg, 
				Text = "TP", 
				TextColor3 = C.text, 
				TextSize = 9, 
				Font = Enum.Font.GothamBold, 
				AutoButtonColor = false, 
				Parent = ib
			})
			rnd(islBtn, 5)
			
			islBtn.MouseButton1Click:Connect(function() 
				press(islBtn) 
				if safeTp(isl.P) then 
					status("âœ“ " .. isl.N, C.green) 
				end 
			end)
		end

		if #results == 0 and not isl then
			npcInfoLbl.Text = "âŒ No results for: \"" .. q .. "\""
			npcInfoLbl.TextColor3 = C.red
			status("âœ— Not found", C.red)
			return
		end

		local total = #results + (isl and 1 or 0)
		npcInfoLbl.Text = string.format("âœ“ Found %d result%s", total, total == 1 and "" or "s")
		npcInfoLbl.TextColor3 = C.green

		for idx, r in ipairs(results) do
			if idx > 25 then break end
			
			local dist = r.dist
			local ds = dist >= 1000 and string.format("%.1fkm", dist / 1000) or string.format("%dm", math.floor(dist))
			
			local rb = mk("Frame", {
				Size = UDim2.new(1, -6, 0, 32), 
				BackgroundColor3 = C.card, 
				BorderSizePixel = 0, 
				LayoutOrder = idx, 
				Parent = npcScroll
			})
			rnd(rb, 6)
			stk(rb, C.stroke, 1)
			
			mk("TextLabel", {
				Size = UDim2.new(0, 20, 1, 0), 
				Position = UDim2.new(0, 4, 0, 0), 
				BackgroundTransparency = 1, 
				Text = r.hasHum and "ğŸ‘¤" or "ğŸ“¦", 
				TextSize = 12, 
				Parent = rb
			})
			
			mk("TextLabel", {
				Size = UDim2.new(1, -110, 1, 0), 
				Position = UDim2.new(0, 24, 0, 0), 
				BackgroundTransparency = 1, 
				Text = r.name, 
				TextColor3 = C.text, 
				TextSize = 10, 
				Font = Enum.Font.GothamSemibold, 
				TextXAlignment = Enum.TextXAlignment.Left, 
				TextTruncate = Enum.TextTruncate.AtEnd, 
				Parent = rb
			})
			
			mk("TextLabel", {
				Size = UDim2.new(0, 42, 0, 16), 
				Position = UDim2.new(1, -90, 0.5, -8), 
				BackgroundColor3 = C.tab, 
				TextColor3 = C.dim, 
				Text = ds, 
				TextSize = 8, 
				Font = Enum.Font.GothamBold, 
				Parent = rb
			}, {rnd(rb, 4)})
			
			local npcBtn = mk("TextButton", {
				Size = UDim2.new(0, 40, 0, 24), 
				Position = UDim2.new(1, -46, 0.5, -12), 
				BackgroundColor3 = C.accent, 
				Text = "TP", 
				TextColor3 = C.text, 
				TextSize = 9, 
				Font = Enum.Font.GothamBold, 
				AutoButtonColor = false, 
				Parent = rb
			})
			rnd(npcBtn, 5)
			
			npcBtn.MouseEnter:Connect(function() 
				tw(npcBtn, TI.f, {BackgroundColor3 = C.accentH}):Play()
				tw(rb, TI.f, {BackgroundColor3 = C.cardH}):Play()
			end)
			
			npcBtn.MouseLeave:Connect(function() 
				tw(npcBtn, TI.f, {BackgroundColor3 = C.accent}):Play()
				tw(rb, TI.f, {BackgroundColor3 = C.card}):Play()
			end)
			
			npcBtn.MouseButton1Click:Connect(function()
				press(npcBtn)
				tw(rb, TI.f, {BackgroundColor3 = C.green}):Play()
				task.delay(0.15, function() 
					tw(rb, TI.s, {BackgroundColor3 = C.card}):Play() 
				end)
				
				if tpFaceNPC(r.part) then 
					status("âœ“ â†’ " .. r.name, C.green) 
				else 
					status("âœ— TP Failed", C.red) 
				end
			end)
		end
	end)
end

goBtn.MouseButton1Click:Connect(function() 
	press(goBtn) 
	doNPCSearch() 
end)

npcIn.FocusLost:Connect(function(enter) 
	if enter then doNPCSearch() end 
end)

npcIn.Focused:Connect(function() 
	local s = npcSrch:FindFirstChildOfClass("UIStroke") 
	if s then tw(s, TI.f, {Color = C.accent, Thickness = 2}):Play() end 
end)

npcIn.FocusLost:Connect(function() 
	local s = npcSrch:FindFirstChildOfClass("UIStroke") 
	if s then tw(s, TI.f, {Color = C.stroke, Thickness = 1.5}):Play() end 
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“„ PAGE 3: POWERS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P3 = mk("ScrollingFrame", {
	Name = "P3", 
	Size = UDim2.new(1, -6, 1, -4), 
	Position = UDim2.new(0, 3, 0, 2), 
	BackgroundTransparency = 1, 
	ScrollBarThickness = 4, 
	ScrollBarImageColor3 = C.accent, 
	CanvasSize = UDim2.new(0, 0, 0, 0), 
	AutomaticCanvasSize = Enum.AutomaticSize.Y, 
	BorderSizePixel = 0, 
	Visible = false, 
	Parent = Content
})

mk("UIListLayout", {
	Padding = UDim.new(0, 4), 
	HorizontalAlignment = Enum.HorizontalAlignment.Center, 
	SortOrder = Enum.SortOrder.LayoutOrder, 
	Parent = P3
})
pad(P3, 3, 6, 0, 0)
pages[3] = P3

-- Helper function to create toggles
local function mkToggle(parent, name, icon, desc, order, callback)
	local frame = mk("Frame", {
		Size = UDim2.new(1, -10, 0, desc and 52 or 36), 
		BackgroundColor3 = C.card, 
		BorderSizePixel = 0, 
		LayoutOrder = order, 
		Parent = parent
	})
	rnd(frame, 7)
	stk(frame, C.stroke, 1)
	
	mk("TextLabel", {
		Size = UDim2.new(0, 22, 0, 22), 
		Position = UDim2.new(0, 7, 0, 7), 
		BackgroundTransparency = 1, 
		Text = icon, 
		TextSize = 14, 
		Parent = frame
	})
	
	mk("TextLabel", {
		Size = UDim2.new(1, -80, 0, 18), 
		Position = UDim2.new(0, 32, 0, 8), 
		BackgroundTransparency = 1, 
		Text = name, 
		TextColor3 = C.text, 
		TextSize = 11, 
		Font = Enum.Font.GothamSemibold, 
		TextXAlignment = Enum.TextXAlignment.Left, 
		Parent = frame
	})
	
	if desc then
		mk("TextLabel", {
			Size = UDim2.new(1, -80, 0, 14), 
			Position = UDim2.new(0, 32, 0, 26), 
			BackgroundTransparency = 1, 
			Text = desc, 
			TextColor3 = C.dim, 
			TextSize = 8, 
			Font = Enum.Font.GothamMedium, 
			TextXAlignment = Enum.TextXAlignment.Left, 
			TextWrapped = true,
			Parent = frame
		})
	end
	
	local tbg = mk("Frame", {
		Size = UDim2.new(0, 38, 0, 18), 
		Position = UDim2.new(1, -46, 0, 9), 
		BackgroundColor3 = C.togOff, 
		BorderSizePixel = 0, 
		Parent = frame
	})
	rnd(tbg, 9)
	
	local tc = mk("Frame", {
		Size = UDim2.new(0, 14, 0, 14), 
		Position = UDim2.new(0, 2, 0.5, -7), 
		BackgroundColor3 = C.text, 
		BorderSizePixel = 0, 
		Parent = tbg
	})
	rnd(tc, 7)
	
	local on = false
	local toggleBtn = mk("TextButton", {
		Size = UDim2.new(1, 0, 1, 0), 
		BackgroundTransparency = 1, 
		Text = "", 
		Parent = frame
	})
	
	toggleBtn.MouseButton1Click:Connect(function()
		on = not on
		tw(tbg, TI.s, {BackgroundColor3 = on and C.togOn or C.togOff}):Play()
		tw(tc, TI.s, {Position = on and UDim2.new(0, 22, 0.5, -7) or UDim2.new(0, 2, 0.5, -7)}):Play()
		callback(on)
		press(toggleBtn)
	end)
	
	return frame, toggleBtn
end

-- Helper function to create sliders
local function mkSlider(parent, name, icon, desc, order, min, max, default, callback)
	local frame = mk("Frame", {
		Size = UDim2.new(1, -10, 0, 54), 
		BackgroundColor3 = C.card, 
		BorderSizePixel = 0, 
		LayoutOrder = order, 
		Parent = parent
	})
	rnd(frame, 7)
	stk(frame, C.stroke, 1)
	
	mk("TextLabel", {
		Size = UDim2.new(0, 20, 0, 20), 
		Position = UDim2.new(0, 7, 0, 5), 
		BackgroundTransparency = 1, 
		Text = icon, 
		TextSize = 13, 
		Parent = frame
	})
	
	mk("TextLabel", {
		Size = UDim2.new(0, 90, 0, 18), 
		Position = UDim2.new(0, 30, 0, 5), 
		BackgroundTransparency = 1, 
		Text = name, 
		TextColor3 = C.text, 
		TextSize = 10, 
		Font = Enum.Font.GothamSemibold, 
		TextXAlignment = Enum.TextXAlignment.Left, 
		Parent = frame
	})
	
	local vl = mk("TextLabel", {
		Size = UDim2.new(0, 42, 0, 18), 
		Position = UDim2.new(1, -50, 0, 5), 
		BackgroundColor3 = C.accent, 
		TextColor3 = C.text, 
		Text = tostring(default), 
		TextSize = 10, 
		Font = Enum.Font.GothamBold, 
		Parent = frame
	})
	rnd(vl, 4)
	
	local track = mk("Frame", {
		Size = UDim2.new(1, -20, 0, 6), 
		Position = UDim2.new(0, 10, 0, 36), 
		BackgroundColor3 = C.tab, 
		BorderSizePixel = 0, 
		Parent = frame
	})
	rnd(track, 3)
	
	local fill = mk("Frame", {
		Size = UDim2.new((default - min) / (max - min), 0, 1, 0), 
		BackgroundColor3 = C.accent, 
		BorderSizePixel = 0, 
		Parent = track
	})
	rnd(fill, 3)
	
	local knob = mk("Frame", {
		Size = UDim2.new(0, 14, 0, 14), 
		Position = UDim2.new((default - min) / (max - min), -7, 0.5, -7), 
		BackgroundColor3 = C.text, 
		BorderSizePixel = 0, 
		Parent = track
	})
	rnd(knob, 7)
	stk(knob, C.accent, 2)
	
	local sliding = false
	local function upd(pos)
		local rel = math.clamp((pos.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
		local val = math.floor(min + rel * (max - min))
		fill.Size = UDim2.new(rel, 0, 1, 0)
		knob.Position = UDim2.new(rel, -7, 0.5, -7)
		vl.Text = tostring(val)
		callback(val)
	end
	
	track.InputBegan:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
			sliding = true 
			upd(input.Position) 
		end 
	end)
	
	knob.InputBegan:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
			sliding = true 
		end 
	end)
	
	UserInputService.InputChanged:Connect(function(input) 
		if sliding and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then 
			upd(input.Position) 
		end 
	end)
	
	UserInputService.InputEnded:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then 
			sliding = false 
		end 
	end)
end

-- Helper for mode selector
local function mkModeSelector(parent, name, icon, desc, order, modes, callback)
	local frame = mk("Frame", {
		Size = UDim2.new(1, -10, 0, 56), 
		BackgroundColor3 = C.card, 
		BorderSizePixel = 0, 
		LayoutOrder = order, 
		Parent = parent
	})
	rnd(frame, 7)
	stk(frame, C.stroke, 1)
	
	mk("TextLabel", {
		Size = UDim2.new(0, 20, 0, 20), 
		Position = UDim2.new(0, 7, 0, 5), 
		BackgroundTransparency = 1, 
		Text = icon, 
		TextSize = 13, 
		Parent = frame
	})
	
	mk("TextLabel", {
		Size = UDim2.new(1, -100, 0, 18), 
		Position = UDim2.new(0, 30, 0, 5), 
		BackgroundTransparency = 1, 
		Text = name, 
		TextColor3 = C.text, 
		TextSize = 10, 
		Font = Enum.Font.GothamSemibold, 
		TextXAlignment = Enum.TextXAlignment.Left, 
		Parent = frame
	})
	
	local modeHolder = mk("Frame", {
		Size = UDim2.new(1, -16, 0, 22), 
		Position = UDim2.new(0, 8, 0, 28), 
		BackgroundTransparency = 1, 
		Parent = frame
	})
	
	mk("UIListLayout", {
		FillDirection = Enum.FillDirection.Horizontal, 
		Padding = UDim.new(0, 4), 
		HorizontalAlignment = Enum.HorizontalAlignment.Left,
		Parent = modeHolder
	})
	
	local modeButtons = {}
	for i, mode in ipairs(modes) do
		local mBtn = mk("TextButton", {
			Size = UDim2.new(0, 48, 0, 22), 
			BackgroundColor3 = i == 1 and C.accent or C.tab, 
			Text = mode, 
			TextColor3 = i == 1 and C.text or C.dim, 
			TextSize = 9, 
			Font = Enum.Font.GothamBold, 
			AutoButtonColor = false, 
			Parent = modeHolder
		})
		rnd(mBtn, 5)
		
		mBtn.MouseButton1Click:Connect(function()
			for j, btn in ipairs(modeButtons) do
				tw(btn, TI.f, {
					BackgroundColor3 = j == i and C.accent or C.tab,
					TextColor3 = j == i and C.text or C.dim
				}):Play()
			end
			callback(i)
			press(mBtn)
		end)
		
		table.insert(modeButtons, mBtn)
	end
end

-- WalkSpeed slider
mkSlider(P3, "Walk Speed", "ğŸƒ", nil, 1, 16, 350, 16, function(val)
	ST.ws = val
	ST.wsActive = true
	local _, hum = getRoot()
	if hum then 
		hum.WalkSpeed = val 
	end
end)

-- Fly section
mk("TextLabel", {
	Size = UDim2.new(1, -10, 0, 22), 
	BackgroundColor3 = C.panel, 
	Text = "âœˆï¸ FLY SYSTEM", 
	TextColor3 = C.text, 
	TextSize = 10, 
	Font = Enum.Font.GothamBlack, 
	LayoutOrder = 2, 
	Parent = P3
}, {rnd(P3, 6)})

mkSlider(P3, "Fly Speed", "ğŸ’¨", nil, 3, 20, 600, 100, function(val) 
	ST.flySpeed = val 
end)

mkModeSelector(P3, "Fly Mode", "ğŸ›¸", nil, 4, {"Normal", "Sonic", "Teleport", "God"}, function(mode)
	ST.flyMode = mode
	if ST.fly then
		stopFly()
		task.wait(0.1)
		startFly()
	end
	status("Fly mode: " .. ({"Normal", "Sonic", "Teleport", "God"})[mode], C.fly)
end)

mkToggle(P3, "Enable Fly", "ğŸ•Šï¸", "WASD+Space+Shift | Ctrl for boost", 5, function(on)
	ST.fly = on
	if on then 
		startFly() 
		status("âœ“ Fly ON [Mode: " .. ({"Normal", "Sonic", "Teleport", "God"})[ST.flyMode] .. "]", C.fly) 
	else 
		stopFly() 
		status("Fly OFF", C.dim) 
	end
end)

-- Ghost section
mk("TextLabel", {
	Size = UDim2.new(1, -10, 0, 22), 
	BackgroundColor3 = C.panel, 
	Text = "ğŸ‘» ASTRAL PROJECTION", 
	TextColor3 = C.text, 
	TextSize = 10, 
	Font = Enum.Font.GothamBlack, 
	LayoutOrder = 6, 
	Parent = P3
}, {rnd(P3, 6)})

mkModeSelector(P3, "Soul Mode", "âœ¨", nil, 7, {"Soul", "Phantom", "Wraith"}, function(mode)
	ST.ghostMode = mode
	if ST.ghost then
		stopGhost()
		task.wait(0.1)
		startGhost()
	end
	status("Soul mode: " .. ({"Soul", "Phantom", "Wraith"})[mode], C.ghost)
end)

mkToggle(P3, "Soul Separation", "ğŸ‘»", "Body stays, soul travels â€¢ God mode â€¢ Noclip", 8, function(on)
	ST.ghost = on
	if on then 
		startGhost() 
		status("âœ“ Soul released â€¢ Press R to return", C.ghost) 
	else 
		stopGhost() 
		status("Soul returned", C.dim) 
	end
end)

mkToggle(P3, "Soul Trail", "âœ¨", "Leave ethereal trail when moving", 9, function(on)
	ST.soulTrail = on
	if ST.ghost then
		stopGhost()
		task.wait(0.1)
		startGhost()
	end
end)

-- Demon section
mk("TextLabel", {
	Size = UDim2.new(1, -10, 0, 22), 
	BackgroundColor3 = C.panel, 
	Text = "ğŸ˜ˆ DEMON AWAKENING", 
	TextColor3 = C.text, 
	TextSize = 10, 
	Font = Enum.Font.GothamBlack, 
	LayoutOrder = 10, 
	Parent = P3
}, {rnd(P3, 6)})

mkModeSelector(P3, "Demon Stage", "ğŸ”¥", nil, 11, {"Stage 1", "Stage 2", "Stage 3"}, function(stage)
	ST.demonStage = stage
	if ST.demon then
		stopDemon()
		task.wait(0.1)
		startDemon()
	end
	status("Demon stage: " .. stage, C.demon)
end)

mkToggle(P3, "Demon V4", "ğŸ˜ˆ", "Mythical transformation â€¢ Aura â€¢ Effects", 12, function(on)
	ST.demon = on
	if on then 
		startDemon() 
		status("ğŸ”¥ DEMON V4 AWAKENED - Stage " .. ST.demonStage .. " ğŸ”¥", C.demon) 
	else 
		stopDemon() 
		status("Demon deactivated", C.dim) 
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ“„ PAGE 4: EXTRA FEATURES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P4 = mk("ScrollingFrame", {
	Name = "P4", 
	Size = UDim2.new(1, -6, 1, -4), 
	Position = UDim2.new(0, 3, 0, 2), 
	BackgroundTransparency = 1, 
	ScrollBarThickness = 4, 
	ScrollBarImageColor3 = C.accent, 
	CanvasSize = UDim2.new(0, 0, 0, 0), 
	AutomaticCanvasSize = Enum.AutomaticSize.Y, 
	BorderSizePixel = 0, 
	Visible = false, 
	Parent = Content
})

mk("UIListLayout", {
	Padding = UDim.new(0, 4), 
	HorizontalAlignment = Enum.HorizontalAlignment.Center, 
	SortOrder = Enum.SortOrder.LayoutOrder, 
	Parent = P4
})
pad(P4, 3, 6, 0, 0)
pages[4] = P4

mkToggle(P4, "Infinite Jump", "â¬†ï¸", "Jump infinitely in the air", 1, function(on)
	ST.infJump = on
	if on then
		ST.jumpConn = UserInputService.JumpRequest:Connect(function()
			local _, hum = getRoot()
			if hum then 
				hum:ChangeState(Enum.HumanoidStateType.Jumping) 
			end
		end)
		status("âœ“ Infinite Jump ON", C.green)
	else
		if ST.jumpConn then 
			ST.jumpConn:Disconnect() 
			ST.jumpConn = nil 
		end
		status("Infinite Jump OFF", C.dim)
	end
end)

mkToggle(P4, "Auto Heal", "â¤ï¸", "Automatically heal when damaged", 2, function(on)
	ST.autoHeal = on
	if on then
		ST.autoHealConn = RunService.Heartbeat:Connect(function()
			local _, hum = getRoot()
			if hum and hum.Health < hum.MaxHealth * 0.9 then
				hum.Health = hum.MaxHealth
			end
		end)
		status("âœ“ Auto Heal ON", C.green)
	else
		if ST.autoHealConn then
			ST.autoHealConn:Disconnect()
			ST.autoHealConn = nil
		end
		status("Auto Heal OFF", C.dim)
	end
end)

mkToggle(P4, "Anti-Fall Damage", "ğŸ›¡ï¸", "Never take fall damage", 3, function(on)
	ST.antiFall = on
	status(on and "âœ“ Anti-Fall ON" or "Anti-Fall OFF", on and C.green or C.dim)
end)

-- Hotkeys section
mk("TextLabel", {
	Size = UDim2.new(1, -10, 0, 22), 
	BackgroundColor3 = C.panel, 
	Text = "âŒ¨ï¸ HOTKEYS", 
	TextColor3 = C.text, 
	TextSize = 10, 
	Font = Enum.Font.GothamBlack, 
	LayoutOrder = 4, 
	Parent = P4
}, {rnd(P4, 6)})

-- Hotkey display
local hotkeys = {
	{"RightCtrl", "Toggle UI"},
	{"F", "Toggle Fly"},
	{"R", "Return to Body"},
	{"T", "Quick TP to Last"},
}

for i, hk in ipairs(hotkeys) do
	local frame = mk("Frame", {
		Size = UDim2.new(1, -10, 0, 28), 
		BackgroundColor3 = C.card, 
		BorderSizePixel = 0, 
		LayoutOrder = 4 + i, 
		Parent = P4
	})
	rnd(frame, 6)
	stk(frame, C.stroke, 1)
	
	mk("TextLabel", {
		Size = UDim2.new(0, 80, 0, 20), 
		Position = UDim2.new(0, 8, 0.5, -10), 
		BackgroundColor3 = C.tab, 
		TextColor3 = C.accent, 
		Text = hk[1], 
		TextSize = 9, 
		Font = Enum.Font.GothamBold, 
		Parent = frame
	}, {rnd(frame, 4)})
	
	mk("TextLabel", {
		Size = UDim2.new(1, -96, 1, 0), 
		Position = UDim2.new(0, 92, 0, 0), 
		BackgroundTransparency = 1, 
		Text = hk[2], 
		TextColor3 = C.text, 
		TextSize = 10, 
		Font = Enum.Font.GothamMedium, 
		TextXAlignment = Enum.TextXAlignment.Left, 
		Parent = frame
	})
end

-- Credits
mk("TextLabel", {
	Size = UDim2.new(1, -10, 0, 40), 
	BackgroundColor3 = C.panel, 
	TextColor3 = C.dim, 
	Text = "âš¡ FLASH TP ALPHA V4.0\nVIP Premium Edition\nÂ© 2024 â€¢ King Legacy Optimized", 
	TextSize = 8, 
	Font = Enum.Font.GothamMedium, 
	TextWrapped = true,
	LayoutOrder = 100, 
	Parent = P4
}, {rnd(P4, 6)})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ® UI CONTROLS & INTERACTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function switchTab(idx)
	if ST.tab == idx then return end
	ST.tab = idx
	
	for i, tb in ipairs(tabs) do
		local isActive = i == idx
		tw(tb, TI.s, {
			BackgroundColor3 = isActive and C.tabA or C.card, 
			TextColor3 = isActive and C.text or C.dim
		}):Play()
		
		local stroke = tb:FindFirstChildOfClass("UIStroke")
		if stroke then
			stroke:Destroy()
		end
		
		if isActive then
			stk(tb, C.accentH, 1.5)
		end
	end
	
	for i, pg in ipairs(pages) do 
		pg.Visible = i == idx 
	end
end

for i, tb in ipairs(tabs) do 
	tb.MouseButton1Click:Connect(function() 
		press(tb) 
		switchTab(i) 
		playSFX(6026984224, 0.2, 1.2)
	end) 
end

local function toggleUI()
	ST.open = not ST.open
	if ST.open then
		Main.Visible = true 
		Main.Size = UDim2.new(0, 230, 0, 0)
		Main.Position = UDim2.new(0, 14, 0.5, 0)
		tw(Main, TI.o, {
			Size = UDim2.new(0, 230, 0, 400),
			Position = UDim2.new(0, 14, 0.5, -200)
		}):Play()
		TogBtn.Visible = false
		playSFX(6026984224, 0.3, 1)
	else
		tw(Main, TI.c, {
			Size = UDim2.new(0, 230, 0, 0),
			Position = UDim2.new(0, 14, 0.5, 0)
		}):Play()
		task.delay(0.14, function() 
			if not ST.open then 
				Main.Visible = false 
				TogBtn.Visible = true 
			end 
		end)
		playSFX(6026984224, 0.3, 0.8)
	end
end

XBtn.MouseButton1Click:Connect(function() 
	press(XBtn) 
	toggleUI() 
end)

TogBtn.MouseButton1Click:Connect(function() 
	press(TogBtn) 
	toggleUI() 
end)

-- Dragging for main window
do
	local dg, di, ds, sp
	TBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dg = true 
			ds = input.Position 
			sp = Main.Position
			input.Changed:Connect(function() 
				if input.UserInputState == Enum.UserInputState.End then 
					dg = false 
				end 
			end)
		end
	end)
	
	TBar.InputChanged:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then 
			di = input 
		end 
	end)
	
	UserInputService.InputChanged:Connect(function(input) 
		if input == di and dg then 
			local d = input.Position - ds 
			Main.Position = UDim2.new(sp.X.Scale, sp.X.Offset + d.X, sp.Y.Scale, sp.Y.Offset + d.Y) 
		end 
	end)
end

-- Dragging for toggle button
do
	local dg2, di2, ds2, sp2
	TogBtn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dg2 = true 
			ds2 = input.Position 
			sp2 = TogBtn.Position
			input.Changed:Connect(function() 
				if input.UserInputState == Enum.UserInputState.End then 
					dg2 = false 
				end 
			end)
		end
	end)
	
	TogBtn.InputChanged:Connect(function(input) 
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then 
			di2 = input 
		end 
	end)
	
	UserInputService.InputChanged:Connect(function(input) 
		if input == di2 and dg2 then 
			local d = input.Position - ds2 
			TogBtn.Position = UDim2.new(sp2.X.Scale, sp2.X.Offset + d.X, sp2.Y.Scale, sp2.Y.Offset + d.Y) 
		end 
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âŒ¨ï¸ HOTKEY SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

UserInputService.InputBegan:Connect(function(input, gpe) 
	if gpe then return end
	
	-- Toggle UI
	if input.KeyCode == Enum.KeyCode.RightControl then 
		toggleUI() 
	end
	
	-- Toggle Fly
	if input.KeyCode == Enum.KeyCode.F then
		ST.fly = not ST.fly
		if ST.fly then 
			startFly() 
			status("âœ“ Fly ON [F]", C.fly) 
		else 
			stopFly() 
			status("Fly OFF [F]", C.dim) 
		end
	end
	
	-- Return to body (Ghost mode)
	if input.KeyCode == Enum.KeyCode.R then
		if ST.ghost then
			returnToBody()
			status("âœ“ Returned to body [R]", C.ghost)
		end
	end
	
	-- Quick TP to last location
	if input.KeyCode == Enum.KeyCode.T then
		if #ST.tpHistory > 0 then
			local last = ST.tpHistory[1]
			if safeTp(last.pos, true) then
				status("âœ“ Quick TP [T]", C.cyan)
			end
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ”„ CONTINUOUS SYSTEMS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- WalkSpeed persistence
RunService.Heartbeat:Connect(function()
	if ST.wsActive and not ST.fly then
		local _, hum = getRoot()
		if hum then 
			hum.WalkSpeed = ST.ws 
		end
	end
end)

-- Anti-fall damage
RunService.Stepped:Connect(function()
	if ST.antiFall then
		local _, hum = getRoot()
		if hum then
			local oldState = hum:GetState()
			if oldState == Enum.HumanoidStateType.FallingDown or oldState == Enum.HumanoidStateType.Freefall then
				hum:ChangeState(Enum.HumanoidStateType.Landed)
			end
		end
	end
end)

-- Character respawn handler
LP.CharacterAdded:Connect(function(char)
	task.wait(0.8)
	
	-- Restore WalkSpeed
	if ST.wsActive then
		local hum = char:WaitForChild("Humanoid", 5)
		if hum then 
			hum.WalkSpeed = ST.ws 
		end
	end
	
	-- Reset powers
	if ST.fly then 
		ST.fly = false 
		stopFly() 
	end
	
	if ST.ghost then 
		ST.ghost = false 
		stopGhost() 
	end
	
	if ST.demon then 
		ST.demon = false 
		stopDemon() 
	end
	
	status("âš  Character respawned - Powers reset", C.orange)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ¬ STARTUP ANIMATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Main.Size = UDim2.new(0, 230, 0, 0)
Main.Position = UDim2.new(0, 14, 0.5, 0)
task.wait(0.2)

tw(Main, TI.o, {
	Size = UDim2.new(0, 230, 0, 400),
	Position = UDim2.new(0, 14, 0.5, -200)
}):Play()

task.wait(0.4)
playSFX(6026984224, 0.4, 1.1)
status("âš¡ FLASH TP V4.0 VIP - Ready!", C.gold)

--[[
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¯ FLASH TP ALPHA V4.0 - FEATURE SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ TELEPORT SYSTEM:
   â€¢ Island quick teleport with search
   â€¢ Smart NPC/Boss finder with AI fuzzy matching
   â€¢ Vietnamese & English language support
   â€¢ Distance calculation & sorting
   â€¢ Teleport history (10 last positions)

âœˆï¸ FLY SYSTEM (4 Modes):
   1. Normal - Smooth balanced flight
   2. Sonic - 2x speed with trail effects
   3. Teleport - Instant short jumps
   4. God - 3x speed ultimate mode
   â€¢ WASD + Space/Shift controls
   â€¢ Ctrl for speed boost
   â€¢ Adjustable fly speed (20-600)
   â€¢ Smooth CFrame movement (anti-cheat safe)
   â€¢ Auto noclip

ğŸ‘» ASTRAL PROJECTION (3 Modes):
   1. Soul - Golden meditation aura on body
   2. Phantom - Dimmed body
   3. Wraith - Dark shadow body
   â€¢ Body stays at position (meditating)
   â€¢ Soul travels freely (95% transparent)
   â€¢ Complete god mode (stealth)
   â€¢ Soul trail effects
   â€¢ Press R to instantly return to body
   â€¢ Noclip through everything

ğŸ˜ˆ DEMON V4 (3 Stages):
   Stage 1: Dark red transformation
   Stage 2: Darker with lightning
   Stage 3: Mythical awakening + screen effects
   â€¢ Dynamic fire/smoke/spark particles
   â€¢ Pulsing demon light
   â€¢ Color correction (Stage 3)
   â€¢ Screen shake (Stage 3)
   â€¢ Character color transformation

ğŸ¯ EXTRA FEATURES:
   â€¢ Infinite Jump
   â€¢ Auto Heal
   â€¢ Anti-Fall Damage
   â€¢ WalkSpeed (16-350)
   â€¢ Quick teleport history

âŒ¨ï¸ HOTKEYS:
   â€¢ RightCtrl - Toggle UI
   â€¢ F - Toggle Fly
   â€¢ R - Return to Body (Ghost mode)
   â€¢ T - Quick TP to Last Location

ğŸ¨ VIP PREMIUM UI:
   â€¢ Modern gradient design
   â€¢ Smooth animations
   â€¢ 4 organized tabs
   â€¢ Mode selectors
   â€¢ Range sliders
   â€¢ Toggle switches
   â€¢ Status notifications
   â€¢ Draggable window
   â€¢ Sound effects

ğŸ”’ ANTI-DETECTION:
   â€¢ Stealth god mode (no math.huge)
   â€¢ CFrame movement (no BodyVelocity)
   â€¢ Smooth transitions
   â€¢ King Legacy optimized

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Made with ğŸ”¥ by AI â€¢ Optimized for King Legacy
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--]]
