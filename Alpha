--[[
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   âš¡ FLASH TP V5.0 â€” COMPLETE ENGINE REWRITE                â•‘
â•‘   Every system rebuilt from scratch â€” Zero legacy bugs       â•‘
â•‘   âœˆï¸ FLY (4 modes) â€¢ ğŸ‘» ASTRAL (3 modes) â€¢ ğŸ˜ˆ DEMON (3)    â•‘
â•‘   ğŸ” AI Search â€¢ ğŸï¸ Island TP â€¢ âŒ¨ï¸ Full Hotkeys            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--]]

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SERVICES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Players       = game:GetService("Players")
local TweenService  = game:GetService("TweenService")
local CoreGui       = game:GetService("CoreGui")
local UIS           = game:GetService("UserInputService")
local RunService    = game:GetService("RunService")
local WS            = game:GetService("Workspace")
local Lighting      = game:GetService("Lighting")
local Debris        = game:GetService("Debris")
local LP            = Players.LocalPlayer

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CLEANUP OLD INSTANCES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
pcall(function()
	local old = CoreGui:FindFirstChild("FlashV5")
	if old then old:Destroy() end
	for _,c in pairs(WS:GetChildren()) do
		if tostring(c.Name):find("AstralBody_") then c:Destroy() end
	end
	local cc = Lighting:FindFirstChild("DemonCC")
	if cc then cc:Destroy() end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ISLAND DATABASE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Islands = {
	{N="Dungeon",             P=Vector3.new(10959.99,134.04,1250.57),  I="ğŸ°", T="Boss"},
	{N="Alien Island",        P=Vector3.new(2186.42,35.82,1302.21),    I="ğŸ‘½", T="Special"},
	{N="Random Fruit",        P=Vector3.new(2064.01,36.25,1093.72),    I="ğŸ", T="Shop"},
	{N="Reset Race Stats",    P=Vector3.new(2052.92,71.81,1071.29),    I="ğŸ”„", T="NPC"},
	{N="Fruit Shop",          P=Vector3.new(2154.84,79.04,824.23),     I="ğŸ›’", T="Shop"},
	{N="Sea Event",           P=Vector3.new(2227.14,362.20,-1205.43),  I="ğŸŒŠ", T="Event"},
	{N="Saber Lord",          P=Vector3.new(1687.59,289.10,-1166.54),  I="âš”ï¸", T="Boss"},
	{N="Awaken Fruit",        P=Vector3.new(2066.98,54.82,551.41),     I="âœ¨", T="Special"},
	{N="Monkey Island",       P=Vector3.new(3725.56,45.42,8813.90),    I="ğŸ’", T="Island"},
	{N="Sea Beasts",          P=Vector3.new(4543.48,47.37,11622.30),   I="ğŸ‰", T="Boss"},
	{N="Luma Forest",         P=Vector3.new(-3935.36,77.38,6265.37),   I="ğŸŒ²", T="Island"},
	{N="Forgotten Arena",     P=Vector3.new(-6105.61,33.69,1014.73),   I="ğŸŸï¸", T="PVP"},
	{N="Drakenhole Fort",     P=Vector3.new(6948.99,49.78,-5753.79),   I="ğŸ²", T="Boss"},
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VIETNAMESE â†’ ENGLISH MAP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ViToEn = {
	["nguc toi"]="dungeon",["hang nguc"]="dungeon",
	["dao nguoi ngoai hanh tinh"]="alien island",["nguoi ngoai hanh tinh"]="alien",
	["trai cay ngau nhien"]="random fruit",["ngau nhien"]="random",
	["dat lai"]="reset",["dat lai chung toc"]="reset race",
	["cua hang trai cay"]="fruit shop",["cua hang"]="shop",
	["su kien bien"]="sea event",["bien"]="sea",
	["chua te kiem"]="saber lord",["kiem"]="saber",
	["thuc tinh trai cay"]="awaken fruit",["thuc tinh"]="awaken",
	["dao khi"]="monkey island",["khi"]="monkey",
	["quai vat bien"]="sea beasts",["quai vat"]="beasts",
	["rung luma"]="luma forest",["rung"]="forest",
	["dau truong bi lang quen"]="forgotten arena",["dau truong"]="arena",
	["phao dai"]="drakenhole fort",["rong"]="drakenhole",
	["boss"]="boss",["trum"]="boss",["dao"]="island",
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COLOR PALETTE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local C = {
	bg      = Color3.fromRGB(10,10,16),
	panel   = Color3.fromRGB(16,16,24),
	card    = Color3.fromRGB(24,24,34),
	cardH   = Color3.fromRGB(34,34,48),
	accent  = Color3.fromRGB(80,160,255),
	accentH = Color3.fromRGB(110,185,255),
	green   = Color3.fromRGB(52,211,153),
	red     = Color3.fromRGB(248,113,113),
	orange  = Color3.fromRGB(251,191,36),
	purple  = Color3.fromRGB(168,85,247),
	pink    = Color3.fromRGB(236,72,153),
	cyan    = Color3.fromRGB(34,211,238),
	gold    = Color3.fromRGB(250,204,21),
	text    = Color3.fromRGB(240,244,248),
	dim     = Color3.fromRGB(130,140,160),
	stroke  = Color3.fromRGB(36,40,56),
	tab     = Color3.fromRGB(18,24,40),
	togOn   = Color3.fromRGB(52,211,153),
	togOff  = Color3.fromRGB(50,56,72),
	input   = Color3.fromRGB(14,20,36),
	fly     = Color3.fromRGB(125,211,252),
	ghost   = Color3.fromRGB(196,181,253),
	demon   = Color3.fromRGB(239,68,68),
	soul    = Color3.fromRGB(167,243,208),
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TWEEN PRESETS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local TI = {
	fast   = TweenInfo.new(0.1,  Enum.EasingStyle.Quart,  Enum.EasingDirection.Out),
	med    = TweenInfo.new(0.22, Enum.EasingStyle.Quart,  Enum.EasingDirection.Out),
	pop    = TweenInfo.new(0.35, Enum.EasingStyle.Back,   Enum.EasingDirection.Out),
	close  = TweenInfo.new(0.16, Enum.EasingStyle.Quart,  Enum.EasingDirection.In),
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STATE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local ST = {
	open     = true,
	tab      = 1,
	-- TP
	tping    = false,
	lastTP   = 0,
	tpHist   = {},
	-- Fly
	fly      = false,
	flyMode  = 1,
	flySpeed = 120,
	flyConns = {},
	flyAnim  = nil,
	-- Ghost
	ghost      = false,
	ghostMode  = 1,
	ghostClone = nil,
	ghostOrig  = {},
	ghostConns = {},
	soulTrail  = true,
	-- Demon
	demon      = false,
	demonStage = 1,
	demonConns = {},
	-- Extra
	infJump    = false,
	jumpConn   = nil,
	ws         = 16,
	wsOn       = false,
	autoHeal   = false,
	healConn   = nil,
	antiFall   = false,
	fallConn   = nil,
}

-- Toggle registry: lets hotkeys update UI
local TogReg = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UTILITY FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function mk(class, props)
	local inst = Instance.new(class)
	for k,v in pairs(props) do
		pcall(function() inst[k] = v end)
	end
	return inst
end

local function rnd(parent, radius)
	return mk("UICorner", {CornerRadius = UDim.new(0, radius or 8), Parent = parent})
end

local function stk(parent, color, thick)
	return mk("UIStroke", {
		Color           = color or C.stroke,
		Thickness       = thick or 1.5,
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		Parent          = parent,
	})
end

local function pad(parent, t, b, l, r)
	return mk("UIPadding", {
		PaddingTop    = UDim.new(0,t or 0),
		PaddingBottom = UDim.new(0,b or 0),
		PaddingLeft   = UDim.new(0,l or 0),
		PaddingRight  = UDim.new(0,r or 0),
		Parent        = parent,
	})
end

local function tw(obj, info, props)
	local t = TweenService:Create(obj, info, props)
	t:Play()
	return t
end

local function press(btn)
	local orig = btn.Size
	tw(btn, TI.fast, {Size = UDim2.new(orig.X.Scale, orig.X.Offset-2, orig.Y.Scale, orig.Y.Offset-1)})
	task.delay(0.08, function()
		pcall(function() tw(btn, TI.pop, {Size = orig}) end)
	end)
end

local function getChar()
	return LP.Character
end

local function getRoot()
	local ch = getChar()
	if not ch then return nil, nil, nil end
	local root = ch:FindFirstChild("HumanoidRootPart")
	local hum  = ch:FindFirstChildOfClass("Humanoid")
	return root, hum, ch
end

local function sfx(id, vol, pitch)
	pcall(function()
		local root = getRoot()
		if not root then root = WS end
		local s = mk("Sound", {
			SoundId       = "rbxassetid://"..tostring(id),
			Volume        = vol or 0.4,
			PlaybackSpeed = pitch or 1,
			Parent        = root,
		})
		s:Play()
		Debris:AddItem(s, 4)
	end)
end

local function disconnectList(list)
	if not list then return end
	for i, conn in pairs(list) do
		if conn and typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
		list[i] = nil
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VIETNAMESE DIACRITICS REMOVER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local DIACRITICS do
	local raw = {
		"aÃ Ã¡áº£Ã£áº¡Äƒáº±áº¯áº³áºµáº·Ã¢áº§áº¥áº©áº«áº­",
		"eÃ¨Ã©áº»áº½áº¹Ãªá»áº¿á»ƒá»…á»‡",
		"iÃ¬Ã­á»‰Ä©á»‹",
		"oÃ²Ã³á»Ãµá»Ã´á»“á»‘á»•á»—á»™Æ¡á»á»›á»Ÿá»¡á»£",
		"uÃ¹Ãºá»§Å©á»¥Æ°á»«á»©á»­á»¯á»±",
		"yá»³Ã½á»·á»¹á»µ",
		"dÄ‘",
	}
	DIACRITICS = {}
	for _, group in ipairs(raw) do
		local chars = {}
		-- Extract UTF-8 characters
		local i = 1
		while i <= #group do
			local b = group:byte(i)
			local len = 1
			if b >= 0xC0 and b < 0xE0 then len = 2
			elseif b >= 0xE0 and b < 0xF0 then len = 3
			elseif b >= 0xF0 then len = 4 end
			table.insert(chars, group:sub(i, i+len-1))
			i = i + len
		end
		local base = chars[1]
		for j = 2, #chars do
			DIACRITICS[chars[j]] = base
			DIACRITICS[chars[j]:upper()] = base:upper()
		end
	end
end

local function stripDiacritics(str)
	local out = {}
	local i = 1
	while i <= #str do
		local b = str:byte(i)
		local len = 1
		if b >= 0xC0 and b < 0xE0 then len = 2
		elseif b >= 0xE0 and b < 0xF0 then len = 3
		elseif b >= 0xF0 then len = 4 end
		local ch = str:sub(i, i+len-1)
		table.insert(out, DIACRITICS[ch] or ch)
		i = i + len
	end
	return table.concat(out)
end

local function translate(raw)
	local cleaned = stripDiacritics(raw):lower()
	cleaned = cleaned:gsub("%s+", " "):match("^%s*(.-)%s*$")
	for vi, en in pairs(ViToEn) do
		if cleaned:find(vi, 1, true) then return en end
	end
	return cleaned
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FUZZY SEARCH ENGINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function fuzzy(query, target)
	local q, t = query:lower(), target:lower()
	if q == t then return 1.0 end
	if t:find(q, 1, true) then return 0.92 end
	if q:find(t, 1, true) then return 0.85 end
	-- Subsequence matching
	local qi, matched = 1, 0
	for i = 1, #t do
		if qi <= #q and t:sub(i,i) == q:sub(qi,qi) then
			matched = matched + 1
			qi = qi + 1
		end
	end
	return matched / math.max(#q, 1)
end

local function scanFolder(folder, query, results, depth)
	if depth > 8 or #results >= 50 then return end
	local ok, children = pcall(function() return folder:GetChildren() end)
	if not ok then return end

	for _, child in ipairs(children) do
		local nameClean = stripDiacritics(child.Name)
		local score = fuzzy(query, nameClean)
		if score >= 0.35 then
			local part = nil
			pcall(function()
				part = child:FindFirstChild("HumanoidRootPart")
					or child:FindFirstChild("Head")
					or child:FindFirstChild("Torso")
					or child:FindFirstChild("UpperTorso")
					or (child:IsA("BasePart") and child)
					or child:FindFirstChildWhichIsA("BasePart", true)
			end)
			if part and part:IsA("BasePart") then
				local isPlayer = false
				for _, plr in ipairs(Players:GetPlayers()) do
					if plr.Character == child then isPlayer = true break end
				end
				if not isPlayer then
					table.insert(results, {
						name   = child.Name,
						part   = part,
						score  = score,
						hasHum = child:FindFirstChildOfClass("Humanoid") ~= nil,
						dist   = 0,
					})
				end
			end
		end
		if not child:IsA("BasePart") and not child:IsA("Camera")
		   and child.Name ~= "Terrain" and depth < 8 then
			scanFolder(child, query, results, depth + 1)
		end
	end
end

local function smartSearch(rawQuery)
	local q = translate(rawQuery)
	local results = {}
	scanFolder(WS, q, results, 0)

	-- Also try direct cleaned query if different
	local alt = stripDiacritics(rawQuery):lower()
	if alt ~= q and #results < 10 then
		scanFolder(WS, alt, results, 0)
	end

	-- Deduplicate
	local seen, unique = {}, {}
	for _, r in ipairs(results) do
		local key = r.name .. tostring(r.part:GetFullName())
		if not seen[key] then
			seen[key] = true
			table.insert(unique, r)
		end
	end

	-- Calculate distances and sort
	local root = getRoot()
	if root then
		for _, r in ipairs(unique) do
			pcall(function()
				r.dist = (r.part.Position - root.Position).Magnitude
			end)
		end
	end
	table.sort(unique, function(a, b)
		if math.abs(a.score - b.score) > 0.12 then return a.score > b.score end
		return a.dist < b.dist
	end)
	return unique
end

local function findIsland(rawQuery)
	local q = translate(rawQuery)
	local best, bestScore = nil, 0
	for _, isl in ipairs(Islands) do
		local s = fuzzy(q, isl.N:lower())
		if s > bestScore then bestScore = s; best = isl end
	end
	return bestScore >= 0.35 and best or nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TELEPORT ENGINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function safeTp(pos)
	if ST.tping then return false end
	local root, hum = getRoot()
	if not root or not hum then return false end

	ST.tping = true
	local ok = pcall(function()
		if hum.Sit then hum.Sit = false; task.wait(0.1) end
		root.CFrame = CFrame.new(pos + Vector3.new(0, 4, 0))
		task.wait(0.06)
		root.AssemblyLinearVelocity  = Vector3.zero
		root.AssemblyAngularVelocity = Vector3.zero
	end)

	if ok then
		table.insert(ST.tpHist, 1, pos)
		if #ST.tpHist > 15 then table.remove(ST.tpHist) end
		sfx(6895079853, 0.35, 1.3)
	end
	ST.tping = false
	return ok
end

local function tpFaceTarget(part)
	if not part then return false end
	local root = getRoot()
	if not root then return false end
	local ok = pcall(function()
		local tPos = part.Position
		local dir = (root.Position - tPos)
		dir = Vector3.new(dir.X, 0, dir.Z)
		if dir.Magnitude < 0.5 then dir = Vector3.new(0, 0, 1) end
		local dest = tPos + dir.Unit * 6
		dest = Vector3.new(dest.X, tPos.Y + 2, dest.Z)
		safeTp(dest)
		task.wait(0.08)
		local r2 = getRoot()
		if r2 then
			r2.CFrame = CFrame.lookAt(r2.Position, Vector3.new(tPos.X, r2.Position.Y, tPos.Z))
		end
	end)
	return ok
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FLY ENGINE  (define disableFly BEFORE enableFly)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function disableFly()
	disconnectList(ST.flyConns)
	if ST.flyAnim then
		pcall(function() ST.flyAnim:Stop(); ST.flyAnim:Destroy() end)
		ST.flyAnim = nil
	end
	local root, hum, char = getRoot()
	if hum then hum.PlatformStand = false end
	if char then
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
				p.CanCollide = true
			end
		end
	end
	if root then
		for _, c in pairs(root:GetChildren()) do
			if c.Name == "FlyTrail" or c.Name == "FlyAtt0" or c.Name == "FlyAtt1" then
				c:Destroy()
			end
		end
	end
end

local function enableFly()
	disableFly()
	local root, hum, char = getRoot()
	if not root or not hum then return end

	-- Mode multipliers
	local mults = {1, 2.2, 1, 3.5}
	local speedMul = mults[ST.flyMode] or 1

	-- Optional trail for Sonic mode
	if ST.flyMode == 2 then
		pcall(function()
			local a0 = mk("Attachment", {Name="FlyAtt0", Parent=root})
			local a1 = mk("Attachment", {Name="FlyAtt1", Parent=root, Position=Vector3.new(0,-2.5,0)})
			mk("Trail", {
				Name        = "FlyTrail",
				Attachment0 = a0,
				Attachment1 = a1,
				Color       = ColorSequence.new(C.cyan, C.accent),
				Transparency= NumberSequence.new{
					NumberSequenceKeypoint.new(0, 0.4),
					NumberSequenceKeypoint.new(1, 1),
				},
				Lifetime      = 0.6,
				MinLength     = 0.05,
				LightEmission = 1,
				Parent        = root,
			})
		end)
	end

	-- Fly animation
	pcall(function()
		local anim = Instance.new("Animation")
		anim.AnimationId = "rbxassetid://507767515"
		local animator = hum:FindFirstChildOfClass("Animator")
		local track = animator and animator:LoadAnimation(anim) or hum:LoadAnimation(anim)
		track.Priority = Enum.AnimationPriority.Action4
		track.Looped = true
		track:Play()
		ST.flyAnim = track
	end)

	-- Teleport-mode accumulator
	local tpAccum = 0

	ST.flyConns[1] = RunService.RenderStepped:Connect(function(dt)
		if not ST.fly then return end
		local r, h, ch = getRoot()
		if not r or not h then return end

		local cam = WS.CurrentCamera
		if not cam then return end

		local dir = Vector3.zero
		if UIS:IsKeyDown(Enum.KeyCode.W)          then dir = dir + cam.CFrame.LookVector end
		if UIS:IsKeyDown(Enum.KeyCode.S)          then dir = dir - cam.CFrame.LookVector end
		if UIS:IsKeyDown(Enum.KeyCode.A)          then dir = dir - cam.CFrame.RightVector end
		if UIS:IsKeyDown(Enum.KeyCode.D)          then dir = dir + cam.CFrame.RightVector end
		if UIS:IsKeyDown(Enum.KeyCode.Space)      then dir = dir + Vector3.yAxis end
		if UIS:IsKeyDown(Enum.KeyCode.LeftShift)  then dir = dir - Vector3.yAxis end

		local boost = UIS:IsKeyDown(Enum.KeyCode.LeftControl) and 2.5 or 1
		local speed = ST.flySpeed * speedMul * boost

		if dir.Magnitude > 0.01 then dir = dir.Unit end

		pcall(function()
			if ST.flyMode == 3 then
				-- Teleport mode: discrete jumps
				tpAccum = tpAccum + dt
				if tpAccum >= 0.08 then
					r.CFrame = r.CFrame + dir * speed * tpAccum
					tpAccum = 0
				end
			else
				r.CFrame = r.CFrame + dir * speed * dt
			end
			r.AssemblyLinearVelocity  = Vector3.zero
			r.AssemblyAngularVelocity = Vector3.zero
		end)

		-- Noclip
		for _, p in pairs(ch:GetDescendants()) do
			if p:IsA("BasePart") then p.CanCollide = false end
		end
		h.PlatformStand = true
	end)

	sfx(6026984224, 0.3, 1.15)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GHOST / ASTRAL PROJECTION  (disable before enable)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function disableGhost()
	disconnectList(ST.ghostConns)

	-- Destroy clone
	if ST.ghostClone then
		pcall(function() ST.ghostClone:Destroy() end)
		ST.ghostClone = nil
	end

	local root, hum, char = getRoot()

	-- Restore transparency / color
	for obj, data in pairs(ST.ghostOrig) do
		if obj and obj.Parent then
			pcall(function()
				if data.trans ~= nil then obj.Transparency = data.trans end
				if data.color ~= nil then obj.Color = data.color end
				if data.mat   ~= nil then obj.Material = data.mat end
			end)
		end
	end
	ST.ghostOrig = {}

	-- Restore collision
	if char then
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
				p.CanCollide = true
			end
		end
	end

	-- Remove effects
	if root then
		for _, c in pairs(root:GetChildren()) do
			if c.Name:find("Soul") or c.Name:find("Astral") then c:Destroy() end
		end
	end

	sfx(1837829565, 0.35, 1.1)
end

local function enableGhost()
	disableGhost()
	local root, hum, char = getRoot()
	if not root or not hum or not char then return end

	ST.ghostOrig = {}

	-- â”€â”€ 1. SAVE ORIGINALS â”€â”€
	for _, p in pairs(char:GetDescendants()) do
		if p:IsA("BasePart") then
			ST.ghostOrig[p] = {trans = p.Transparency, color = p.Color, mat = p.Material}
		elseif p:IsA("Decal") then
			ST.ghostOrig[p] = {trans = p.Transparency}
		end
	end

	-- â”€â”€ 2. CREATE MEDITATING BODY CLONE â”€â”€
	pcall(function()
		local clone = char:Clone()
		-- Strip scripts
		for _, d in pairs(clone:GetDescendants()) do
			if d:IsA("BaseScript") then d:Destroy() end
		end
		-- Anchor everything
		for _, p in pairs(clone:GetDescendants()) do
			if p:IsA("BasePart") then
				p.Anchored   = true
				p.CanCollide = false
			end
		end

		-- Mode-specific body effects
		local cloneRoot = clone:FindFirstChild("HumanoidRootPart")
		if ST.ghostMode == 1 and cloneRoot then
			-- Soul: golden meditation aura
			local att = mk("Attachment", {Name="SoulAuraClone", Parent=cloneRoot})
			mk("ParticleEmitter", {
				Color         = ColorSequence.new(C.gold),
				Size          = NumberSequence.new{NumberSequenceKeypoint.new(0,1.2), NumberSequenceKeypoint.new(1,0)},
				Transparency  = NumberSequence.new{NumberSequenceKeypoint.new(0,0.5), NumberSequenceKeypoint.new(1,1)},
				Lifetime      = NumberRange.new(1.5,2.5),
				Rate          = 20,
				Speed         = NumberRange.new(0.8,2),
				SpreadAngle   = Vector2.new(360,360),
				Acceleration  = Vector3.new(0,2.5,0),
				LightEmission = 0.8,
				Parent        = att,
			})
			mk("PointLight", {Color=C.gold, Brightness=1.5, Range=14, Parent=cloneRoot})
		elseif ST.ghostMode == 2 then
			for _, p in pairs(clone:GetDescendants()) do
				if p:IsA("BasePart") then p.Transparency = math.min(p.Transparency+0.55, 0.9) end
			end
		elseif ST.ghostMode == 3 then
			for _, p in pairs(clone:GetDescendants()) do
				if p:IsA("BasePart") then
					p.Color    = Color3.fromRGB(18,18,24)
					p.Material = Enum.Material.SmoothPlastic
				end
			end
		end

		clone.Name   = "AstralBody_"..LP.UserId
		clone.Parent = WS
		ST.ghostClone = clone
	end)

	-- â”€â”€ 3. TRANSFORM PLAYER INTO SOUL â”€â”€
	local soulAlpha = ({0.88, 0.93, 0.82})[ST.ghostMode]
	local soulColor = ({C.soul, C.ghost, Color3.fromRGB(55,55,75)})[ST.ghostMode]

	for _, p in pairs(char:GetDescendants()) do
		if p:IsA("BasePart") then
			p.Transparency = soulAlpha
			p.Color        = soulColor
			p.Material     = Enum.Material.Neon
		elseif p:IsA("Decal") then
			p.Transparency = 0.97
		end
	end

	-- â”€â”€ 4. SOUL PARTICLES â”€â”€
	pcall(function()
		local att = mk("Attachment", {Name="SoulAura", Parent=root})
		mk("ParticleEmitter", {
			Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, soulColor),
				ColorSequenceKeypoint.new(1, C.purple),
			},
			Size = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 2.2),
				NumberSequenceKeypoint.new(0.5, 1),
				NumberSequenceKeypoint.new(1, 0),
			},
			Transparency = NumberSequence.new{
				NumberSequenceKeypoint.new(0, 0.4),
				NumberSequenceKeypoint.new(1, 1),
			},
			Texture       = "rbxasset://textures/particles/smoke_main.dds",
			Lifetime      = NumberRange.new(1, 1.8),
			Rate          = 40,
			Speed         = NumberRange.new(1.5, 3),
			SpreadAngle   = Vector2.new(360, 360),
			Acceleration  = Vector3.new(0, 2, 0),
			LightEmission = 0.85,
			Parent        = att,
		})
		-- Sparkles
		mk("ParticleEmitter", {
			Color = ColorSequence.new(Color3.fromRGB(210,230,255)),
			Size  = NumberSequence.new{NumberSequenceKeypoint.new(0,0.25), NumberSequenceKeypoint.new(1,0)},
			Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)},
			Lifetime      = NumberRange.new(0.5, 1),
			Rate          = 30,
			Speed         = NumberRange.new(2, 4),
			SpreadAngle   = Vector2.new(20, 20),
			LightEmission = 1,
			Parent        = att,
		})
		mk("PointLight", {Name="SoulLight", Color=soulColor, Brightness=3, Range=16, Parent=root})

		-- Soul trail
		if ST.soulTrail then
			local a0 = mk("Attachment", {Name="SoulTrailA0", Parent=root})
			local a1 = mk("Attachment", {Name="SoulTrailA1", Parent=root, Position=Vector3.new(0,-2.5,0)})
			mk("Trail", {
				Name        = "SoulTrail",
				Attachment0 = a0,
				Attachment1 = a1,
				Color       = ColorSequence.new{
					ColorSequenceKeypoint.new(0, soulColor),
					ColorSequenceKeypoint.new(1, C.ghost),
				},
				Transparency = NumberSequence.new{
					NumberSequenceKeypoint.new(0, 0.3),
					NumberSequenceKeypoint.new(1, 1),
				},
				Lifetime      = 0.8,
				MinLength     = 0.05,
				LightEmission = 0.9,
				Parent        = root,
			})
		end
	end)

	-- â”€â”€ 5. GOD MODE + NOCLIP LOOP â”€â”€
	ST.ghostConns[1] = RunService.Heartbeat:Connect(function()
		local r, h, ch = getRoot()
		if not h or not ch then return end
		-- Heal
		if h.Health < h.MaxHealth then h.Health = h.MaxHealth end
		-- Noclip
		for _, p in pairs(ch:GetDescendants()) do
			if p:IsA("BasePart") then p.CanCollide = false end
		end
	end)

	-- â”€â”€ 6. PULSING LIGHT â”€â”€
	ST.ghostConns[2] = RunService.Heartbeat:Connect(function()
		if not ST.ghost then return end
		local r = getRoot()
		if not r then return end
		local lt = r:FindFirstChild("SoulLight")
		if lt then
			local t = tick()
			lt.Brightness = 2.8 + math.sin(t*3.5)*0.7
			lt.Range      = 15  + math.sin(t*2.8)*3
		end
	end)

	sfx(1837829565, 0.45, 0.85)
end

local function returnToBody()
	if not ST.ghost or not ST.ghostClone then return end
	local bodyRoot = ST.ghostClone:FindFirstChild("HumanoidRootPart")
	if bodyRoot then
		safeTp(bodyRoot.Position)
		sfx(6026984224, 0.35, 1.4)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEMON V4  (disable before enable)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function disableDemon()
	disconnectList(ST.demonConns)

	local root, hum, char = getRoot()
	if root then
		for _, c in pairs(root:GetChildren()) do
			if c.Name:find("Demon") then c:Destroy() end
		end
	end
	pcall(function()
		local cc = Lighting:FindFirstChild("DemonCC")
		if cc then cc:Destroy() end
	end)

	-- Restore character appearance
	if char then
		pcall(function()
			local bc = char:FindFirstChildOfClass("BodyColors")
			for _, p in pairs(char:GetDescendants()) do
				if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
					p.Material = Enum.Material.SmoothPlastic
					if bc then
						if p.Name:find("Torso") or p.Name:find("UpperTorso") or p.Name:find("LowerTorso") then
							p.Color = bc.TorsoColor3
						elseif p.Name:find("Head") then
							p.Color = bc.HeadColor3
						elseif p.Name:find("Arm") or p.Name:find("Hand") then
							p.Color = bc.LeftArmColor3
						elseif p.Name:find("Leg") or p.Name:find("Foot") then
							p.Color = bc.LeftLegColor3
						end
					else
						p.Color = Color3.fromRGB(163,162,165)
					end
				end
			end
		end)
	end
end

local function enableDemon()
	disableDemon()
	local root, hum, char = getRoot()
	if not root or not hum or not char then return end

	local stage = ST.demonStage

	-- Scream animation
	pcall(function()
		local a = Instance.new("Animation")
		a.AnimationId = "rbxassetid://507770677"
		local animator = hum:FindFirstChildOfClass("Animator")
		local track = animator and animator:LoadAnimation(a) or hum:LoadAnimation(a)
		track.Priority = Enum.AnimationPriority.Action4
		track:Play()
		task.delay(1.4, function() pcall(function() track:Stop() end) end)
	end)
	sfx(262562442, 0.7, 0.65 + stage*0.1)

	-- Color transformation
	local demonColors = {
		Color3.fromRGB(100,0,0),
		Color3.fromRGB(55,0,0),
		Color3.fromRGB(20,0,0),
	}
	pcall(function()
		for _, p in pairs(char:GetDescendants()) do
			if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then
				p.Color    = demonColors[stage]
				p.Material = Enum.Material.Neon
			end
		end
	end)

	-- Aura particles
	local att = mk("Attachment", {Name="DemonAura", Parent=root})

	-- Fire
	mk("ParticleEmitter", {
		Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255,30,0)),
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(150,0,0)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(40,0,0)),
		},
		Size = NumberSequence.new{
			NumberSequenceKeypoint.new(0, 2.5+stage),
			NumberSequenceKeypoint.new(0.5, 1.2+stage*0.4),
			NumberSequenceKeypoint.new(1, 0),
		},
		Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0.15), NumberSequenceKeypoint.new(1,1)},
		Texture       = "rbxasset://textures/particles/fire_main.dds",
		Lifetime      = NumberRange.new(0.5, 1.2),
		Rate          = 70 + stage*35,
		Speed         = NumberRange.new(3+stage, 6+stage*2),
		SpreadAngle   = Vector2.new(30,30),
		Acceleration  = Vector3.new(0, 4+stage, 0),
		RotSpeed      = NumberRange.new(-180,180),
		LightEmission = 0.9,
		LightInfluence= 0.1,
		Parent        = att,
	})

	-- Smoke
	mk("ParticleEmitter", {
		Color = ColorSequence.new(Color3.fromRGB(math.max(25-stage*5,0),0,0)),
		Size  = NumberSequence.new{NumberSequenceKeypoint.new(0,3.5+stage), NumberSequenceKeypoint.new(1,0.8)},
		Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0.35), NumberSequenceKeypoint.new(1,1)},
		Texture       = "rbxasset://textures/particles/smoke_main.dds",
		Lifetime      = NumberRange.new(1,1.8),
		Rate          = 30 + stage*12,
		Speed         = NumberRange.new(1,3),
		SpreadAngle   = Vector2.new(360,360),
		Acceleration  = Vector3.new(0,2.5,0),
		LightEmission = 0.25,
		Parent        = att,
	})

	-- Sparks
	mk("ParticleEmitter", {
		Color = ColorSequence.new(Color3.fromRGB(255, 40+stage*20, 0)),
		Size  = NumberSequence.new{NumberSequenceKeypoint.new(0,0.3+stage*0.08), NumberSequenceKeypoint.new(1,0)},
		Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,1)},
		Lifetime      = NumberRange.new(0.35,0.8),
		Rate          = 50 + stage*18,
		Speed         = NumberRange.new(4+stage*2, 9+stage*3),
		SpreadAngle   = Vector2.new(18,18),
		LightEmission = 1,
		Parent        = att,
	})

	-- Stage 3 extra sparkles
	if stage == 3 then
		mk("ParticleEmitter", {
			Texture  = "rbxasset://textures/particles/sparkles_main.dds",
			Color    = ColorSequence.new(Color3.fromRGB(150,0,0)),
			Size     = NumberSequence.new{NumberSequenceKeypoint.new(0,1.8), NumberSequenceKeypoint.new(1,0)},
			Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,0.25), NumberSequenceKeypoint.new(1,1)},
			Lifetime      = NumberRange.new(1.2,2.2),
			Rate          = 22,
			Speed         = NumberRange.new(2.5,5),
			SpreadAngle   = Vector2.new(360,360),
			Rotation      = NumberRange.new(0,360),
			RotSpeed      = NumberRange.new(-90,90),
			LightEmission = 0.8,
			Parent        = att,
		})
	end

	-- Light
	local dLight = mk("PointLight", {
		Name       = "DemonLight",
		Color      = Color3.fromRGB(255,0,0),
		Brightness = 3 + stage,
		Range      = 18 + stage*7,
		Parent     = root,
	})

	-- Pulsing
	ST.demonConns[1] = RunService.Heartbeat:Connect(function()
		if not ST.demon then return end
		pcall(function()
			local t = tick()
			dLight.Brightness = (3+stage) + math.sin(t*(3.5+stage))*( 1+stage*0.4)
			dLight.Range      = (18+stage*7) + math.sin(t*(2.8+stage))*(3+stage*1.5)
		end)
	end)

	-- Stage 3: color correction + subtle shake
	if stage == 3 then
		pcall(function()
			local cc = mk("ColorCorrectionEffect", {
				Name       = "DemonCC",
				Saturation = -0.25,
				TintColor  = Color3.fromRGB(255,210,210),
				Parent     = Lighting,
			})
		end)
		ST.demonConns[2] = RunService.RenderStepped:Connect(function()
			pcall(function()
				local cam = WS.CurrentCamera
				if cam then
					cam.CFrame = cam.CFrame * CFrame.Angles(
						math.rad(math.random(-10,10)*0.04),
						math.rad(math.random(-10,10)*0.04),
						0
					)
				end
			end)
		end)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GUI CONSTRUCTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local GUI = mk("ScreenGui", {
	Name            = "FlashV5",
	ResetOnSpawn    = false,
	ZIndexBehavior  = Enum.ZIndexBehavior.Sibling,
	IgnoreGuiInset  = false,
})
pcall(function() GUI.Parent = CoreGui end)
if not GUI.Parent then GUI.Parent = LP:WaitForChild("PlayerGui") end

-- â”€â”€ TOGGLE BUTTON (minimized) â”€â”€
local TogBtn = mk("TextButton", {
	Size             = UDim2.new(0,46,0,46),
	Position         = UDim2.new(0,12,0.5,-23),
	BackgroundColor3 = C.accent,
	Text             = "âš¡",
	TextSize         = 18,
	Font             = Enum.Font.GothamBold,
	TextColor3       = C.text,
	AutoButtonColor  = false,
	Visible          = false,
	ZIndex           = 10,
	Parent           = GUI,
})
rnd(TogBtn, 23)
stk(TogBtn, C.accentH, 2)

-- â”€â”€ MAIN FRAME â”€â”€
local Main = mk("Frame", {
	Name             = "Main",
	Size             = UDim2.new(0,236,0,420),
	Position         = UDim2.new(0,12,0.5,-210),
	BackgroundColor3 = C.bg,
	BorderSizePixel  = 0,
	ClipsDescendants = true,
	Parent           = GUI,
})
rnd(Main, 14)
stk(Main, C.stroke, 2)

-- â”€â”€ TITLE BAR â”€â”€
local TBar = mk("Frame", {
	Size             = UDim2.new(1,0,0,40),
	BackgroundColor3 = C.panel,
	BorderSizePixel  = 0,
	Parent           = Main,
})
rnd(TBar, 14)
-- Bottom cover (square off bottom corners)
mk("Frame", {
	Size             = UDim2.new(1,0,0,14),
	Position         = UDim2.new(0,0,1,-14),
	BackgroundColor3 = C.panel,
	BorderSizePixel  = 0,
	Parent           = TBar,
})

-- Accent line
local accentLine = mk("Frame", {
	Size             = UDim2.new(1,0,0,2),
	Position         = UDim2.new(0,0,1,0),
	BackgroundColor3 = C.accent,
	BorderSizePixel  = 0,
	Parent           = TBar,
})
local accentGrad = mk("UIGradient", {
	Color    = ColorSequence.new{
		ColorSequenceKeypoint.new(0, C.accent),
		ColorSequenceKeypoint.new(0.5, C.cyan),
		ColorSequenceKeypoint.new(1, C.accent),
	},
	Rotation = 0,
	Parent   = accentLine,
})
-- Animate gradient
task.spawn(function()
	while task.wait(0.025) do
		pcall(function() accentGrad.Offset = Vector2.new(math.sin(tick()*2)*0.5, 0) end)
	end
end)

-- Title
mk("TextLabel", {
	Size                = UDim2.new(1,-120,1,0),
	Position            = UDim2.new(0,12,0,0),
	BackgroundTransparency = 1,
	Text                = "âš¡ FLASH",
	TextColor3          = C.text,
	TextSize            = 16,
	Font                = Enum.Font.GothamBlack,
	TextXAlignment      = Enum.TextXAlignment.Left,
	Parent              = TBar,
})

-- Version badge
local vBadge = mk("TextLabel", {
	Size             = UDim2.new(0,36,0,16),
	Position         = UDim2.new(0,72,0.5,-8),
	BackgroundColor3 = C.purple,
	TextColor3       = C.text,
	Text             = "V5",
	TextSize         = 9,
	Font             = Enum.Font.GothamBold,
	Parent           = TBar,
})
rnd(vBadge, 4)

-- VIP badge
local vipBadge = mk("TextLabel", {
	Size             = UDim2.new(0,30,0,16),
	Position         = UDim2.new(0,112,0.5,-8),
	BackgroundColor3 = C.gold,
	TextColor3       = C.bg,
	Text             = "VIP",
	TextSize         = 9,
	Font             = Enum.Font.GothamBold,
	Parent           = TBar,
})
rnd(vipBadge, 4)

-- Close button
local XBtn = mk("TextButton", {
	Size             = UDim2.new(0,28,0,26),
	Position         = UDim2.new(1,-34,0.5,-13),
	BackgroundColor3 = C.card,
	Text             = "âœ•",
	TextColor3       = C.dim,
	TextSize         = 12,
	Font             = Enum.Font.GothamBold,
	AutoButtonColor  = false,
	Parent           = TBar,
})
rnd(XBtn, 7)
stk(XBtn, C.stroke, 1)

XBtn.MouseEnter:Connect(function()
	tw(XBtn, TI.fast, {BackgroundColor3=C.red, TextColor3=C.text})
end)
XBtn.MouseLeave:Connect(function()
	tw(XBtn, TI.fast, {BackgroundColor3=C.card, TextColor3=C.dim})
end)

-- â”€â”€ TAB BAR â”€â”€
local TabBar = mk("Frame", {
	Size             = UDim2.new(1,-14,0,30),
	Position         = UDim2.new(0,7,0,44),
	BackgroundColor3 = C.tab,
	BorderSizePixel  = 0,
	Parent           = Main,
})
rnd(TabBar, 7)
pad(TabBar, 3, 3, 4, 4)
stk(TabBar, C.stroke, 1)

mk("UIListLayout", {
	FillDirection       = Enum.FillDirection.Horizontal,
	Padding             = UDim.new(0, 4),
	HorizontalAlignment = Enum.HorizontalAlignment.Center,
	VerticalAlignment   = Enum.VerticalAlignment.Center,
	Parent              = TabBar,
})

local tabData = {
	{icon = "ğŸï¸", tip = "Islands"},
	{icon = "ğŸ”", tip = "Search"},
	{icon = "âš™ï¸", tip = "Powers"},
	{icon = "ğŸ¯", tip = "Extra"},
}

local tabBtns = {}
local pages   = {}

for i, td in ipairs(tabData) do
	local tb = mk("TextButton", {
		Size             = UDim2.new(0, 50, 0, 22),
		BackgroundColor3 = i==1 and C.accent or C.card,
		Text             = td.icon,
		TextColor3       = i==1 and C.text or C.dim,
		TextSize         = 12,
		Font             = Enum.Font.GothamBold,
		AutoButtonColor  = false,
		LayoutOrder       = i,
		Parent           = TabBar,
	})
	rnd(tb, 6)
	if i == 1 then stk(tb, C.accentH, 1.5) end
	tabBtns[i] = tb
end

-- Content container
local Content = mk("Frame", {
	Size                = UDim2.new(1,0,1,-80),
	Position            = UDim2.new(0,0,0,78),
	BackgroundTransparency = 1,
	ClipsDescendants    = true,
	Parent              = Main,
})

-- Status label
local StatusLbl = mk("TextLabel", {
	Size                = UDim2.new(1,-14,0,16),
	Position            = UDim2.new(0,7,1,-19),
	BackgroundTransparency = 1,
	Text                = "",
	TextColor3          = C.green,
	TextSize            = 9,
	Font                = Enum.Font.GothamBold,
	TextXAlignment      = Enum.TextXAlignment.Left,
	TextTransparency    = 1,
	ZIndex              = 5,
	Parent              = Main,
})

local statusThread = nil
local function status(msg, col)
	StatusLbl.Text       = msg
	StatusLbl.TextColor3 = col or C.green
	tw(StatusLbl, TI.fast, {TextTransparency = 0})
	if statusThread then pcall(task.cancel, statusThread) end
	statusThread = task.delay(3.5, function()
		pcall(function() tw(StatusLbl, TI.med, {TextTransparency = 1}) end)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI COMPONENT BUILDERS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function mkScroll(parent, order, vis)
	local scroll = mk("ScrollingFrame", {
		Size                 = UDim2.new(1,-8,1,-4),
		Position             = UDim2.new(0,4,0,2),
		BackgroundTransparency = 1,
		ScrollBarThickness   = 4,
		ScrollBarImageColor3 = C.accent,
		CanvasSize           = UDim2.new(0,0,0,0),
		AutomaticCanvasSize  = Enum.AutomaticSize.Y,
		BorderSizePixel      = 0,
		Visible              = vis or false,
		Parent               = parent,
	})
	mk("UIListLayout", {
		Padding             = UDim.new(0, 5),
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		SortOrder           = Enum.SortOrder.LayoutOrder,
		Parent              = scroll,
	})
	pad(scroll, 3, 8, 0, 0)
	return scroll
end

local function mkSectionHeader(parent, text, order)
	local lbl = mk("TextLabel", {
		Size             = UDim2.new(1,-12,0,24),
		BackgroundColor3 = C.panel,
		Text             = text,
		TextColor3       = C.text,
		TextSize         = 10,
		Font             = Enum.Font.GothamBlack,
		LayoutOrder       = order,
		Parent           = parent,
	})
	rnd(lbl, 6)
	return lbl
end

local function mkToggle(parent, name, icon, desc, order, stateKey, callback)
	local h = desc and 54 or 38
	local frame = mk("Frame", {
		Size             = UDim2.new(1,-12,0,h),
		BackgroundColor3 = C.card,
		BorderSizePixel  = 0,
		LayoutOrder       = order,
		Parent           = parent,
	})
	rnd(frame, 8)
	stk(frame, C.stroke, 1)

	mk("TextLabel", {
		Size=UDim2.new(0,22,0,22), Position=UDim2.new(0,8,0,8),
		BackgroundTransparency=1, Text=icon, TextSize=14, Parent=frame,
	})
	mk("TextLabel", {
		Size=UDim2.new(1,-82,0,18), Position=UDim2.new(0,34,0,9),
		BackgroundTransparency=1, Text=name, TextColor3=C.text,
		TextSize=11, Font=Enum.Font.GothamSemibold,
		TextXAlignment=Enum.TextXAlignment.Left, Parent=frame,
	})
	if desc then
		mk("TextLabel", {
			Size=UDim2.new(1,-82,0,16), Position=UDim2.new(0,34,0,28),
			BackgroundTransparency=1, Text=desc, TextColor3=C.dim,
			TextSize=8, Font=Enum.Font.GothamMedium,
			TextXAlignment=Enum.TextXAlignment.Left, TextWrapped=true,
			Parent=frame,
		})
	end

	local tbg = mk("Frame", {
		Size=UDim2.new(0,40,0,20), Position=UDim2.new(1,-48,0,9),
		BackgroundColor3=C.togOff, BorderSizePixel=0, Parent=frame,
	})
	rnd(tbg, 10)

	local knob = mk("Frame", {
		Size=UDim2.new(0,16,0,16), Position=UDim2.new(0,2,0.5,-8),
		BackgroundColor3=C.text, BorderSizePixel=0, Parent=tbg,
	})
	rnd(knob, 8)

	local function setVisual(on)
		tw(tbg,  TI.med, {BackgroundColor3 = on and C.togOn or C.togOff})
		tw(knob, TI.med, {Position = on and UDim2.new(0,22,0.5,-8) or UDim2.new(0,2,0.5,-8)})
	end

	local clickBtn = mk("TextButton", {
		Size=UDim2.new(1,0,1,0), BackgroundTransparency=1, Text="", Parent=frame,
	})
	clickBtn.MouseButton1Click:Connect(function()
		ST[stateKey] = not ST[stateKey]
		setVisual(ST[stateKey])
		callback(ST[stateKey])
		press(clickBtn)
	end)

	-- Register for external toggling (hotkeys)
	TogReg[stateKey] = {
		setVisual = setVisual,
		callback  = callback,
	}

	return frame
end

local function mkSlider(parent, name, icon, order, min, max, default, callback)
	local frame = mk("Frame", {
		Size=UDim2.new(1,-12,0,56), BackgroundColor3=C.card,
		BorderSizePixel=0, LayoutOrder=order, Parent=parent,
	})
	rnd(frame, 8)
	stk(frame, C.stroke, 1)

	mk("TextLabel", {
		Size=UDim2.new(0,20,0,20), Position=UDim2.new(0,8,0,5),
		BackgroundTransparency=1, Text=icon, TextSize=13, Parent=frame,
	})
	mk("TextLabel", {
		Size=UDim2.new(0,90,0,18), Position=UDim2.new(0,32,0,5),
		BackgroundTransparency=1, Text=name, TextColor3=C.text,
		TextSize=10, Font=Enum.Font.GothamSemibold,
		TextXAlignment=Enum.TextXAlignment.Left, Parent=frame,
	})

	local valLbl = mk("TextLabel", {
		Size=UDim2.new(0,44,0,18), Position=UDim2.new(1,-52,0,5),
		BackgroundColor3=C.accent, TextColor3=C.text,
		Text=tostring(default), TextSize=10, Font=Enum.Font.GothamBold,
		Parent=frame,
	})
	rnd(valLbl, 4)

	local track = mk("Frame", {
		Size=UDim2.new(1,-22,0,8), Position=UDim2.new(0,11,0,38),
		BackgroundColor3=C.tab, BorderSizePixel=0, Parent=frame,
	})
	rnd(track, 4)

	local pct = (default-min)/(max-min)
	local fill = mk("Frame", {
		Size=UDim2.new(pct,0,1,0), BackgroundColor3=C.accent,
		BorderSizePixel=0, Parent=track,
	})
	rnd(fill, 4)

	local knob = mk("Frame", {
		Size=UDim2.new(0,16,0,16), Position=UDim2.new(pct,-8,0.5,-8),
		BackgroundColor3=C.text, BorderSizePixel=0, Parent=track,
	})
	rnd(knob, 8)
	stk(knob, C.accent, 2)

	local sliding = false
	local function update(inputPos)
		local rel = math.clamp((inputPos.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
		local val = math.floor(min + rel * (max-min))
		fill.Size     = UDim2.new(rel, 0, 1, 0)
		knob.Position = UDim2.new(rel, -8, 0.5, -8)
		valLbl.Text   = tostring(val)
		callback(val)
	end

	track.InputBegan:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1
		or inp.UserInputType == Enum.UserInputType.Touch then
			sliding = true
			update(inp.Position)
		end
	end)
	knob.InputBegan:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1
		or inp.UserInputType == Enum.UserInputType.Touch then
			sliding = true
		end
	end)
	UIS.InputChanged:Connect(function(inp)
		if sliding and (inp.UserInputType == Enum.UserInputType.MouseMovement
		or inp.UserInputType == Enum.UserInputType.Touch) then
			update(inp.Position)
		end
	end)
	UIS.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1
		or inp.UserInputType == Enum.UserInputType.Touch then
			sliding = false
		end
	end)

	return frame
end

local function mkModeSelector(parent, name, icon, order, modes, stateKey, callback)
	local frame = mk("Frame", {
		Size=UDim2.new(1,-12,0,58), BackgroundColor3=C.card,
		BorderSizePixel=0, LayoutOrder=order, Parent=parent,
	})
	rnd(frame, 8)
	stk(frame, C.stroke, 1)

	mk("TextLabel", {
		Size=UDim2.new(0,20,0,20), Position=UDim2.new(0,8,0,5),
		BackgroundTransparency=1, Text=icon, TextSize=13, Parent=frame,
	})
	mk("TextLabel", {
		Size=UDim2.new(1,-40,0,18), Position=UDim2.new(0,32,0,5),
		BackgroundTransparency=1, Text=name, TextColor3=C.text,
		TextSize=10, Font=Enum.Font.GothamSemibold,
		TextXAlignment=Enum.TextXAlignment.Left, Parent=frame,
	})

	local holder = mk("Frame", {
		Size=UDim2.new(1,-18,0,24), Position=UDim2.new(0,9,0,28),
		BackgroundTransparency=1, Parent=frame,
	})
	mk("UIListLayout", {
		FillDirection=Enum.FillDirection.Horizontal,
		Padding=UDim.new(0,4),
		Parent=holder,
	})

	local btns = {}
	local currentMode = ST[stateKey] or 1

	for i, label in ipairs(modes) do
		local active = i == currentMode
		local mBtn = mk("TextButton", {
			Size=UDim2.new(0, math.floor((236-30)/#modes - 4), 0, 24),
			BackgroundColor3 = active and C.accent or C.tab,
			Text=label, TextColor3 = active and C.text or C.dim,
			TextSize=9, Font=Enum.Font.GothamBold,
			AutoButtonColor=false, Parent=holder,
		})
		rnd(mBtn, 5)

		mBtn.MouseButton1Click:Connect(function()
			ST[stateKey] = i
			for j, b in ipairs(btns) do
				tw(b, TI.fast, {
					BackgroundColor3 = j==i and C.accent or C.tab,
					TextColor3       = j==i and C.text or C.dim,
				})
			end
			callback(i)
			press(mBtn)
		end)
		btns[i] = mBtn
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PAGE 1: ISLANDS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P1 = mkScroll(Content, 1, true)
pages[1] = P1

-- Search box
local islSearchFrame = mk("Frame", {
	Size=UDim2.new(1,-12,0,34), BackgroundColor3=C.input,
	BorderSizePixel=0, LayoutOrder=0, Parent=P1,
})
rnd(islSearchFrame, 8)
local islSearchStroke = stk(islSearchFrame, C.stroke, 1.5)

mk("TextLabel", {
	Size=UDim2.new(0,26,1,0), Position=UDim2.new(0,4,0,0),
	BackgroundTransparency=1, Text="ğŸ”", TextSize=13, Parent=islSearchFrame,
})

local islInput = mk("TextBox", {
	Size=UDim2.new(1,-36,1,0), Position=UDim2.new(0,28,0,0),
	BackgroundTransparency=1, PlaceholderText="Search islands...",
	PlaceholderColor3=C.dim, Text="", TextColor3=C.text,
	TextSize=11, Font=Enum.Font.GothamMedium,
	TextXAlignment=Enum.TextXAlignment.Left,
	ClearTextOnFocus=false, Parent=islSearchFrame,
})

islInput.Focused:Connect(function()
	tw(islSearchStroke, TI.fast, {Color=C.accent, Thickness=2})
end)
islInput.FocusLost:Connect(function()
	tw(islSearchStroke, TI.fast, {Color=C.stroke, Thickness=1.5})
end)

-- Island cards
local islCards = {}
for i, loc in ipairs(Islands) do
	local card = mk("Frame", {
		Size=UDim2.new(1,-12,0,36), BackgroundColor3=C.card,
		BorderSizePixel=0, LayoutOrder=i, Parent=P1,
	})
	rnd(card, 8)
	stk(card, C.stroke, 1)

	mk("TextLabel", {
		Size=UDim2.new(0,24,1,0), Position=UDim2.new(0,6,0,0),
		BackgroundTransparency=1, Text=loc.I, TextSize=14, Parent=card,
	})
	mk("TextLabel", {
		Size=UDim2.new(1,-88,0,18), Position=UDim2.new(0,32,0,4),
		BackgroundTransparency=1, Text=loc.N, TextColor3=C.text,
		TextSize=11, Font=Enum.Font.GothamSemibold,
		TextXAlignment=Enum.TextXAlignment.Left,
		TextTruncate=Enum.TextTruncate.AtEnd, Parent=card,
	})
	-- Type badge
	local badge = mk("TextLabel", {
		Size=UDim2.new(0,42,0,14), Position=UDim2.new(0,32,0,20),
		BackgroundColor3=C.tab, TextColor3=C.dim,
		Text=loc.T, TextSize=7, Font=Enum.Font.GothamBold, Parent=card,
	})
	rnd(badge, 3)

	local tpBtn = mk("TextButton", {
		Size=UDim2.new(0,48,0,28), Position=UDim2.new(1,-54,0.5,-14),
		BackgroundColor3=C.accent, Text="TP", TextColor3=C.text,
		TextSize=10, Font=Enum.Font.GothamBold,
		AutoButtonColor=false, Parent=card,
	})
	rnd(tpBtn, 6)

	tpBtn.MouseEnter:Connect(function()
		tw(tpBtn, TI.fast, {BackgroundColor3=C.accentH})
		tw(card, TI.fast, {BackgroundColor3=C.cardH})
	end)
	tpBtn.MouseLeave:Connect(function()
		tw(tpBtn, TI.fast, {BackgroundColor3=C.accent})
		tw(card, TI.fast, {BackgroundColor3=C.card})
	end)
	tpBtn.MouseButton1Click:Connect(function()
		press(tpBtn)
		tw(card, TI.fast, {BackgroundColor3=C.green})
		task.delay(0.2, function()
			pcall(function() tw(card, TI.med, {BackgroundColor3=C.card}) end)
		end)
		if safeTp(loc.P) then
			status("âœ“ â†’ "..loc.N, C.green)
		else
			status("âœ— TP failed", C.red)
		end
	end)

	islCards[i] = {frame=card, name=loc.N}
end

-- Filter islands
islInput:GetPropertyChangedSignal("Text"):Connect(function()
	local q = translate(islInput.Text)
	for _, c in ipairs(islCards) do
		c.frame.Visible = q == "" or fuzzy(q, c.name:lower()) >= 0.3
	end
end)

-- Enter to TP
islInput.FocusLost:Connect(function(enter)
	if enter and islInput.Text ~= "" then
		local isl = findIsland(islInput.Text)
		if isl then
			if safeTp(isl.P) then status("âœ“ â†’ "..isl.N, C.green)
			else status("âœ— TP failed", C.red) end
		else
			status("âœ— Island not found", C.red)
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PAGE 2: SMART SEARCH
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P2 = mk("Frame", {
	Name="P2", Size=UDim2.new(1,0,1,0),
	BackgroundTransparency=1, Visible=false, Parent=Content,
})
pages[2] = P2

local searchFrame = mk("Frame", {
	Size=UDim2.new(1,-14,0,34), Position=UDim2.new(0,7,0,4),
	BackgroundColor3=C.input, BorderSizePixel=0, Parent=P2,
})
rnd(searchFrame, 8)
local searchStroke = stk(searchFrame, C.stroke, 1.5)

mk("TextLabel", {
	Size=UDim2.new(0,26,1,0), Position=UDim2.new(0,4,0,0),
	BackgroundTransparency=1, Text="ğŸ”", TextSize=13, Parent=searchFrame,
})

local searchInput = mk("TextBox", {
	Size=UDim2.new(1,-70,1,0), Position=UDim2.new(0,28,0,0),
	BackgroundTransparency=1, PlaceholderText="NPC / Boss / Location...",
	PlaceholderColor3=C.dim, Text="", TextColor3=C.text,
	TextSize=11, Font=Enum.Font.GothamMedium,
	TextXAlignment=Enum.TextXAlignment.Left,
	ClearTextOnFocus=false, Parent=searchFrame,
})

searchInput.Focused:Connect(function()
	tw(searchStroke, TI.fast, {Color=C.accent, Thickness=2})
end)
searchInput.FocusLost:Connect(function()
	tw(searchStroke, TI.fast, {Color=C.stroke, Thickness=1.5})
end)

local goBtn = mk("TextButton", {
	Size=UDim2.new(0,34,0,26), Position=UDim2.new(1,-38,0.5,-13),
	BackgroundColor3=C.accent, Text="GO", TextColor3=C.text,
	TextSize=10, Font=Enum.Font.GothamBold,
	AutoButtonColor=false, Parent=searchFrame,
})
rnd(goBtn, 6)
goBtn.MouseEnter:Connect(function() tw(goBtn, TI.fast, {BackgroundColor3=C.accentH}) end)
goBtn.MouseLeave:Connect(function() tw(goBtn, TI.fast, {BackgroundColor3=C.accent}) end)

mk("TextLabel", {
	Size=UDim2.new(1,-14,0,14), Position=UDim2.new(0,7,0,41),
	BackgroundTransparency=1,
	Text="âœ¨ AI fuzzy search â€¢ Vietnamese & English",
	TextColor3=C.dim, TextSize=8, Font=Enum.Font.GothamMedium,
	TextXAlignment=Enum.TextXAlignment.Left, Parent=P2,
})

local resultScroll = mk("ScrollingFrame", {
	Size=UDim2.new(1,-14,1,-62), Position=UDim2.new(0,7,0,58),
	BackgroundTransparency=1, ScrollBarThickness=4,
	ScrollBarImageColor3=C.accent, CanvasSize=UDim2.new(0,0,0,0),
	AutomaticCanvasSize=Enum.AutomaticSize.Y,
	BorderSizePixel=0, Parent=P2,
})
mk("UIListLayout", {
	Padding=UDim.new(0,4), HorizontalAlignment=Enum.HorizontalAlignment.Center,
	SortOrder=Enum.SortOrder.LayoutOrder, Parent=resultScroll,
})
pad(resultScroll, 2, 4, 0, 0)

local infoLbl = mk("TextLabel", {
	Size=UDim2.new(1,-8,0,20), BackgroundTransparency=1,
	Text="", TextColor3=C.dim, TextSize=10,
	Font=Enum.Font.GothamMedium, LayoutOrder=0, Parent=resultScroll,
})

local function clearResults()
	for _, c in pairs(resultScroll:GetChildren()) do
		if c:IsA("Frame") then c:Destroy() end
	end
end

local function doSearch()
	local q = searchInput.Text:match("^%s*(.-)%s*$")
	if #q < 2 then status("âš  Min 2 characters", C.orange) return end

	clearResults()
	infoLbl.Text      = "ğŸ” Scanning workspace..."
	infoLbl.TextColor3 = C.orange

	task.defer(function()
		local isl     = findIsland(q)
		local results = smartSearch(q)

		-- Island match card
		if isl then
			local ib = mk("Frame", {
				Size=UDim2.new(1,-8,0,34), BackgroundColor3=C.cyan,
				BorderSizePixel=0, LayoutOrder=0, Parent=resultScroll,
			})
			rnd(ib, 7)
			mk("TextLabel", {
				Size=UDim2.new(0,22,1,0), Position=UDim2.new(0,6,0,0),
				BackgroundTransparency=1, Text=isl.I, TextSize=13, Parent=ib,
			})
			mk("TextLabel", {
				Size=UDim2.new(1,-76,1,0), Position=UDim2.new(0,28,0,0),
				BackgroundTransparency=1, Text="ğŸï¸ "..isl.N,
				TextColor3=C.bg, TextSize=11, Font=Enum.Font.GothamBold,
				TextXAlignment=Enum.TextXAlignment.Left, Parent=ib,
			})
			local islBtn = mk("TextButton", {
				Size=UDim2.new(0,42,0,26), Position=UDim2.new(1,-48,0.5,-13),
				BackgroundColor3=C.bg, Text="TP", TextColor3=C.text,
				TextSize=9, Font=Enum.Font.GothamBold,
				AutoButtonColor=false, Parent=ib,
			})
			rnd(islBtn, 5)
			islBtn.MouseButton1Click:Connect(function()
				press(islBtn)
				if safeTp(isl.P) then status("âœ“ â†’ "..isl.N, C.green) end
			end)
		end

		local total = #results + (isl and 1 or 0)
		if total == 0 then
			infoLbl.Text      = 'âŒ No results for "'..q..'"'
			infoLbl.TextColor3 = C.red
			status("âœ— Not found", C.red)
			return
		end

		infoLbl.Text      = string.format("âœ“ Found %d result%s", total, total==1 and "" or "s")
		infoLbl.TextColor3 = C.green

		for idx, r in ipairs(results) do
			if idx > 30 then break end
			local dist = r.dist or 0
			local ds = dist >= 1000 and string.format("%.1fk", dist/1000) or string.format("%dm", math.floor(dist))

			local rb = mk("Frame", {
				Size=UDim2.new(1,-8,0,34), BackgroundColor3=C.card,
				BorderSizePixel=0, LayoutOrder=idx, Parent=resultScroll,
			})
			rnd(rb, 7)
			stk(rb, C.stroke, 1)

			mk("TextLabel", {
				Size=UDim2.new(0,20,1,0), Position=UDim2.new(0,5,0,0),
				BackgroundTransparency=1, Text=r.hasHum and "ğŸ‘¤" or "ğŸ“¦",
				TextSize=12, Parent=rb,
			})
			mk("TextLabel", {
				Size=UDim2.new(1,-114,1,0), Position=UDim2.new(0,26,0,0),
				BackgroundTransparency=1, Text=r.name, TextColor3=C.text,
				TextSize=10, Font=Enum.Font.GothamSemibold,
				TextXAlignment=Enum.TextXAlignment.Left,
				TextTruncate=Enum.TextTruncate.AtEnd, Parent=rb,
			})

			local distBadge = mk("TextLabel", {
				Size=UDim2.new(0,44,0,18), Position=UDim2.new(1,-94,0.5,-9),
				BackgroundColor3=C.tab, TextColor3=C.dim,
				Text=ds, TextSize=8, Font=Enum.Font.GothamBold, Parent=rb,
			})
			rnd(distBadge, 4)

			local npcBtn = mk("TextButton", {
				Size=UDim2.new(0,42,0,26), Position=UDim2.new(1,-48,0.5,-13),
				BackgroundColor3=C.accent, Text="TP", TextColor3=C.text,
				TextSize=9, Font=Enum.Font.GothamBold,
				AutoButtonColor=false, Parent=rb,
			})
			rnd(npcBtn, 5)

			npcBtn.MouseEnter:Connect(function()
				tw(npcBtn, TI.fast, {BackgroundColor3=C.accentH})
				tw(rb, TI.fast, {BackgroundColor3=C.cardH})
			end)
			npcBtn.MouseLeave:Connect(function()
				tw(npcBtn, TI.fast, {BackgroundColor3=C.accent})
				tw(rb, TI.fast, {BackgroundColor3=C.card})
			end)
			npcBtn.MouseButton1Click:Connect(function()
				press(npcBtn)
				tw(rb, TI.fast, {BackgroundColor3=C.green})
				task.delay(0.2, function()
					pcall(function() tw(rb, TI.med, {BackgroundColor3=C.card}) end)
				end)
				if tpFaceTarget(r.part) then
					status("âœ“ â†’ "..r.name, C.green)
				else
					status("âœ— TP failed", C.red)
				end
			end)
		end
	end)
end

goBtn.MouseButton1Click:Connect(function() press(goBtn); doSearch() end)
searchInput.FocusLost:Connect(function(enter) if enter then doSearch() end end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PAGE 3: POWERS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P3 = mkScroll(Content, 3, false)
pages[3] = P3

-- WalkSpeed
mkSlider(P3, "Walk Speed", "ğŸƒ", 1, 16, 400, 16, function(val)
	ST.ws   = val
	ST.wsOn = true
	local _, hum = getRoot()
	if hum then hum.WalkSpeed = val end
end)

-- â”€â”€ FLY SECTION â”€â”€
mkSectionHeader(P3, "âœˆï¸ FLY SYSTEM", 2)

mkSlider(P3, "Fly Speed", "ğŸ’¨", 3, 20, 800, 120, function(val)
	ST.flySpeed = val
end)

mkModeSelector(P3, "Fly Mode", "ğŸ›¸", 4, {"Normal","Sonic","Teleport","God"}, "flyMode", function(mode)
	if ST.fly then
		disableFly()
		task.wait(0.05)
		enableFly()
	end
	local names = {"Normal","Sonic","Teleport","God"}
	status("Fly mode: "..names[mode], C.fly)
end)

mkToggle(P3, "Enable Fly", "ğŸ•Šï¸", "WASD+Space+Shift â€¢ Ctrl=boost", 5, "fly", function(on)
	if on then
		enableFly()
		local names = {"Normal","Sonic","Teleport","God"}
		status("âœ“ Fly ON ["..names[ST.flyMode].."]", C.fly)
	else
		disableFly()
		status("Fly OFF", C.dim)
	end
end)

-- â”€â”€ GHOST SECTION â”€â”€
mkSectionHeader(P3, "ğŸ‘» ASTRAL PROJECTION", 6)

mkModeSelector(P3, "Soul Mode", "âœ¨", 7, {"Soul","Phantom","Wraith"}, "ghostMode", function(mode)
	if ST.ghost then
		disableGhost()
		task.wait(0.1)
		enableGhost()
	end
	local names = {"Soul","Phantom","Wraith"}
	status("Soul mode: "..names[mode], C.ghost)
end)

mkToggle(P3, "Soul Separation", "ğŸ‘»", "Body stays â€¢ Soul travels â€¢ God+Noclip", 8, "ghost", function(on)
	if on then
		enableGhost()
		status("âœ“ Soul released â€¢ R to return", C.ghost)
	else
		disableGhost()
		status("Soul returned", C.dim)
	end
end)

mkToggle(P3, "Soul Trail", "âœ¨", "Ethereal trail when moving", 9, "soulTrail", function(on)
	if ST.ghost then
		disableGhost()
		task.wait(0.1)
		enableGhost()
	end
end)

-- â”€â”€ DEMON SECTION â”€â”€
mkSectionHeader(P3, "ğŸ˜ˆ DEMON AWAKENING", 10)

mkModeSelector(P3, "Demon Stage", "ğŸ”¥", 11, {"Stage 1","Stage 2","Stage 3"}, "demonStage", function(stage)
	if ST.demon then
		disableDemon()
		task.wait(0.1)
		enableDemon()
	end
	status("Demon stage: "..stage, C.demon)
end)

mkToggle(P3, "Demon V4", "ğŸ˜ˆ", "Mythical transformation â€¢ Fire aura", 12, "demon", function(on)
	if on then
		enableDemon()
		status("ğŸ”¥ DEMON V4 â€” Stage "..ST.demonStage.." ğŸ”¥", C.demon)
	else
		disableDemon()
		status("Demon OFF", C.dim)
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PAGE 4: EXTRAS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local P4 = mkScroll(Content, 4, false)
pages[4] = P4

mkToggle(P4, "Infinite Jump", "â¬†ï¸", "Jump in mid-air infinitely", 1, "infJump", function(on)
	if on then
		ST.jumpConn = UIS.JumpRequest:Connect(function()
			local _, hum = getRoot()
			if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
		end)
		status("âœ“ Infinite Jump ON", C.green)
	else
		if ST.jumpConn then ST.jumpConn:Disconnect(); ST.jumpConn = nil end
		status("Infinite Jump OFF", C.dim)
	end
end)

mkToggle(P4, "Auto Heal", "â¤ï¸", "Restore health when damaged", 2, "autoHeal", function(on)
	if on then
		ST.healConn = RunService.Heartbeat:Connect(function()
			local _, hum = getRoot()
			if hum and hum.Health < hum.MaxHealth * 0.95 then
				hum.Health = hum.MaxHealth
			end
		end)
		status("âœ“ Auto Heal ON", C.green)
	else
		if ST.healConn then ST.healConn:Disconnect(); ST.healConn = nil end
		status("Auto Heal OFF", C.dim)
	end
end)

mkToggle(P4, "Anti-Fall Damage", "ğŸ›¡ï¸", "Prevent all fall damage", 3, "antiFall", function(on)
	if on then
		ST.fallConn = RunService.Heartbeat:Connect(function()
			local _, hum = getRoot()
			if hum then
				pcall(function()
					hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
					hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
				end)
			end
		end)
		status("âœ“ Anti-Fall ON", C.green)
	else
		if ST.fallConn then ST.fallConn:Disconnect(); ST.fallConn = nil end
		pcall(function()
			local _, hum = getRoot()
			if hum then
				hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
				hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
			end
		end)
		status("Anti-Fall OFF", C.dim)
	end
end)

-- Hotkeys info
mkSectionHeader(P4, "âŒ¨ï¸ HOTKEYS", 4)

local hotkeyInfo = {
	{"RightCtrl", "Toggle UI"},
	{"F",         "Toggle Fly"},
	{"R",         "Return to Body"},
	{"T",         "Quick TP Last"},
}
for i, hk in ipairs(hotkeyInfo) do
	local hf = mk("Frame", {
		Size=UDim2.new(1,-12,0,30), BackgroundColor3=C.card,
		BorderSizePixel=0, LayoutOrder=4+i, Parent=P4,
	})
	rnd(hf, 7)
	stk(hf, C.stroke, 1)

	local keyBadge = mk("TextLabel", {
		Size=UDim2.new(0,82,0,22), Position=UDim2.new(0,6,0.5,-11),
		BackgroundColor3=C.tab, TextColor3=C.accent,
		Text=hk[1], TextSize=9, Font=Enum.Font.GothamBold, Parent=hf,
	})
	rnd(keyBadge, 4)

	mk("TextLabel", {
		Size=UDim2.new(1,-100,1,0), Position=UDim2.new(0,94,0,0),
		BackgroundTransparency=1, Text=hk[2], TextColor3=C.text,
		TextSize=10, Font=Enum.Font.GothamMedium,
		TextXAlignment=Enum.TextXAlignment.Left, Parent=hf,
	})
end

-- Credits
local cred = mk("TextLabel", {
	Size=UDim2.new(1,-12,0,44), BackgroundColor3=C.panel,
	TextColor3=C.dim, Text="âš¡ FLASH TP V5.0\nComplete Engine Rewrite\nKing Legacy Optimized",
	TextSize=8, Font=Enum.Font.GothamMedium, TextWrapped=true,
	LayoutOrder=100, Parent=P4,
})
rnd(cred, 7)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TAB SWITCHING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function switchTab(idx)
	if ST.tab == idx then return end
	ST.tab = idx
	for i, tb in ipairs(tabBtns) do
		local active = i == idx
		tw(tb, TI.med, {
			BackgroundColor3 = active and C.accent or C.card,
			TextColor3       = active and C.text or C.dim,
		})
		-- Update strokes
		for _, child in pairs(tb:GetChildren()) do
			if child:IsA("UIStroke") then child:Destroy() end
		end
		if active then stk(tb, C.accentH, 1.5) end
	end
	for i, pg in ipairs(pages) do
		pg.Visible = i == idx
	end
end

for i, tb in ipairs(tabBtns) do
	tb.MouseButton1Click:Connect(function()
		press(tb)
		switchTab(i)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI TOGGLE (OPEN / CLOSE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function toggleUI()
	ST.open = not ST.open
	if ST.open then
		Main.Visible = true
		Main.Size     = UDim2.new(0, 236, 0, 0)
		Main.Position = UDim2.new(Main.Position.X.Scale, Main.Position.X.Offset, Main.Position.Y.Scale, Main.Position.Y.Offset + 210)
		tw(Main, TI.pop, {
			Size     = UDim2.new(0, 236, 0, 420),
			Position = UDim2.new(Main.Position.X.Scale, Main.Position.X.Offset, Main.Position.Y.Scale, Main.Position.Y.Offset - 210),
		})
		TogBtn.Visible = false
		sfx(6026984224, 0.25, 1)
	else
		local origPos = Main.Position
		tw(Main, TI.close, {
			Size     = UDim2.new(0, 236, 0, 0),
			Position = UDim2.new(origPos.X.Scale, origPos.X.Offset, origPos.Y.Scale, origPos.Y.Offset + 210),
		})
		task.delay(0.18, function()
			if not ST.open then
				Main.Visible   = false
				TogBtn.Visible = true
			end
		end)
		sfx(6026984224, 0.25, 0.8)
	end
end

XBtn.MouseButton1Click:Connect(function() press(XBtn); toggleUI() end)
TogBtn.MouseButton1Click:Connect(function() press(TogBtn); toggleUI() end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DRAGGING
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function makeDraggable(handle, target)
	local dragging, dragStart, startPos
	handle.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1
		or input.UserInputType == Enum.UserInputType.Touch then
			dragging  = true
			dragStart = input.Position
			startPos  = target.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then dragging = false end
			end)
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement
		or input.UserInputType == Enum.UserInputType.Touch) then
			local delta = input.Position - dragStart
			target.Position = UDim2.new(
				startPos.X.Scale, startPos.X.Offset + delta.X,
				startPos.Y.Scale, startPos.Y.Offset + delta.Y
			)
		end
	end)
end

makeDraggable(TBar, Main)
makeDraggable(TogBtn, TogBtn)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- HOTKEY SYSTEM (with UI sync)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function externalToggle(key)
	ST[key] = not ST[key]
	local reg = TogReg[key]
	if reg then
		reg.setVisual(ST[key])
		reg.callback(ST[key])
	end
end

UIS.InputBegan:Connect(function(input, gpe)
	if gpe then return end

	if input.KeyCode == Enum.KeyCode.RightControl then
		toggleUI()
	elseif input.KeyCode == Enum.KeyCode.F then
		externalToggle("fly")
	elseif input.KeyCode == Enum.KeyCode.R then
		if ST.ghost then
			returnToBody()
			status("âœ“ Returned to body [R]", C.ghost)
		end
	elseif input.KeyCode == Enum.KeyCode.T then
		if #ST.tpHist > 0 then
			if safeTp(ST.tpHist[1]) then
				status("âœ“ Quick TP [T]", C.cyan)
			end
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONTINUOUS SYSTEMS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- WalkSpeed persistence
RunService.Heartbeat:Connect(function()
	if ST.wsOn and not ST.fly then
		local _, hum = getRoot()
		if hum and math.abs(hum.WalkSpeed - ST.ws) > 1 then
			hum.WalkSpeed = ST.ws
		end
	end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CHARACTER RESPAWN HANDLER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LP.CharacterAdded:Connect(function(char)
	task.wait(1)

	-- Restore WalkSpeed
	if ST.wsOn then
		local hum = char:WaitForChild("Humanoid", 5)
		if hum then hum.WalkSpeed = ST.ws end
	end

	-- Reset active powers (they reference old character)
	local powersToReset = {"fly", "ghost", "demon"}
	for _, key in ipairs(powersToReset) do
		if ST[key] then
			ST[key] = false
			local reg = TogReg[key]
			if reg then reg.setVisual(false) end
		end
	end

	-- Cleanup systems
	disableFly()
	disableGhost()
	disableDemon()

	-- Reset extra features
	if ST.infJump and ST.jumpConn then
		ST.jumpConn:Disconnect()
		ST.jumpConn = UIS.JumpRequest:Connect(function()
			local _, hum = getRoot()
			if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
		end)
	end

	if ST.autoHeal and ST.healConn then
		ST.healConn:Disconnect()
		ST.healConn = RunService.Heartbeat:Connect(function()
			local _, hum = getRoot()
			if hum and hum.Health < hum.MaxHealth * 0.95 then
				hum.Health = hum.MaxHealth
			end
		end)
	end

	status("âš  Respawned â€” Powers reset", C.orange)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STARTUP ANIMATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Main.BackgroundTransparency = 1
for _, child in pairs(Main:GetDescendants()) do
	if child:IsA("GuiObject") then
		pcall(function() child.BackgroundTransparency = 1 end)
		pcall(function() child.TextTransparency = 1 end)
	end
end

task.wait(0.15)
tw(Main, TI.pop, {BackgroundTransparency = 0})
task.wait(0.1)

for _, child in pairs(Main:GetDescendants()) do
	if child:IsA("GuiObject") then
		pcall(function()
			if child:IsA("TextLabel") or child:IsA("TextButton") or child:IsA("TextBox") then
				tw(child, TI.med, {BackgroundTransparency = child.Name == "" and 0 or child.BackgroundTransparency, TextTransparency = 0})
			else
				tw(child, TI.med, {BackgroundTransparency = 0})
			end
		end)
	end
end

task.wait(0.3)
sfx(6026984224, 0.35, 1.1)
status("âš¡ FLASH V5.0 â€” All Systems Online", C.gold)
